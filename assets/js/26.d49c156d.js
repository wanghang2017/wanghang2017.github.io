(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{530:function(t,e,s){"use strict";s.r(e);var a=s(6),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"react篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react篇"}},[t._v("#")]),t._v(" react篇")]),t._v(" "),s("h4",{attrs:{id:"domdiff-参考地址https-blog-csdn-net-one-girl-article-details-81086289"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#domdiff-参考地址https-blog-csdn-net-one-girl-article-details-81086289"}},[t._v("#")]),t._v(" DOMdiff  参考地址https://blog.csdn.net/one_girl/article/details/81086289")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20180717182348969",alt:"è¿éåå¾çæè¿°"}})]),t._v(" "),s("p",[t._v("DIFF算法在执行时有三个维度，分别是Tree DIFF、Component DIFF和Element DIFF，执行时按顺序依次执行，它们的差异仅仅因为DIFF粒度不同、执行先后顺序不同")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/2018071718264787",alt:"è¿éåå¾çæè¿°"}})]),t._v(" "),s("p",[t._v("Tree DIFF是对树的每一层进行遍历，如果某组件不存在了，则会直接销毁。如图所示，左边是旧属，右边是新属，第一层是R组件，一模一样，不会发生变化；第二层进入Component DIFF，同一类型组件继续比较下去，发现A组件没有，所以直接删掉A、B、C组件；继续第三层，重新创建A、B、C组件。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20180717182802621",alt:"img"}})]),t._v(" "),s("p",[t._v("如图所示，第一层遍历完，进行第二层遍历时，D和G组件是不同类型的组件，不同类型组件直接进行替换，将D删掉，再将G重建。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdn.net/20180717182842111",alt:"è¿éåå¾çæè¿°"}})]),t._v(" "),s("p",[t._v("Element DIFF紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定key，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。如图所示，第一步将D删掉，第二步增加E，再次执行时A和B只需要移动位置即可。")]),t._v(" "),s("h4",{attrs:{id:"组件key值得中要性-参考地址https-www-jianshu-com-p-e639dbc325ef"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件key值得中要性-参考地址https-www-jianshu-com-p-e639dbc325ef"}},[t._v("#")]),t._v(" 组件key值得中要性  参考地址https://www.jianshu.com/p/e639dbc325ef")]),t._v(" "),s("p",[t._v("组件重新render得到新的虚拟dom；")]),t._v(" "),s("p",[t._v("新老两个虚拟dom进行diff，新老版的都有"),s("code",[t._v("key=0")]),t._v("的组件，react认为同一个组件，则只可能更新组件；")]),t._v(" "),s("p",[t._v("然后比较其children，发现内容的文本内容不同（由a---\x3ec)，而input组件并没有变化，这时触发组件的"),s("code",[t._v("componentWillReceiveProps")]),t._v("方法，从而更新其子组件文本内容;")]),t._v(" "),s("p",[t._v("因为组件的children中input组件没有变化，其又与父组件传入的新"),s("code",[t._v("props")]),t._v("没有关联，所以input组件不会更新(即其"),s("code",[t._v("componentWillReceiveProps")]),t._v("方法不会被执行)，导致用户输入的值不会变化。\n这就是index作为key存在的问题，所以不要使用index作为key。\n"),s("strong",[t._v("也不能用Math.random()生成key值")]),t._v("，这样虽然能保证key值的唯一性，但是会导致数组每次改变时，组件都重新销毁并新建，耗费性能。还可能导致一些意想不到的问题。")]),t._v(" "),s("h4",{attrs:{id:"fiber架构-https-www-cnblogs-com-coderhf-p-12802882-html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber架构-https-www-cnblogs-com-coderhf-p-12802882-html"}},[t._v("#")]),t._v(" Fiber架构  （https://www.cnblogs.com/coderhf/p/12802882.html）")]),t._v(" "),s("p",[t._v("解决的问题：")]),t._v(" "),s("ul",[s("li",[t._v("暂停工作，稍后再回来。")]),t._v(" "),s("li",[t._v("为不同类型的工作分配优先权。")]),t._v(" "),s("li",[t._v("重用以前完成的工作。")]),t._v(" "),s("li",[t._v("如果不再需要，则中止工作")])]),t._v(" "),s("p",[t._v("如何工作：")]),t._v(" "),s("p",[t._v("​\t1. "),s("code",[t._v("ReactDOM.render()")]),t._v(" 和 "),s("code",[t._v("setState")]),t._v(" 的时候开始创建更新。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("2. 将创建的更新加入任务队列，等待调度。\n3. 在 requestIdleCallback 空闲时执行任务。\n4. 从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。\n5. 生成 effectList。\n6. 根据 EffectList 更新 DOM。\n")])])]),s("p",[t._v("核心api：")]),t._v(" "),s("p",[t._v("​\t低优先级任务由"),s("code",[t._v("requestIdleCallback")]),t._v("处理；")]),t._v(" "),s("p",[t._v("​\t高优先级任务，如动画相关的由"),s("code",[t._v("requestAnimationFrame")]),t._v("处理；")]),t._v(" "),s("p",[t._v("操作系统常用任务调度策略：")]),t._v(" "),s("p",[t._v("​\t先来先服务（FCFS）调度算法、短作业（进程）优先调度算法（SJ/PF）、最高优先权优先调度算法（FPF）、高响应比优先调度算法（HRN）、时间片轮转法（RR）、多级队列反馈法。")]),t._v(" "),s("h4",{attrs:{id:"react-16-3-引入的两个生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-16-3-引入的两个生命周期"}},[t._v("#")]),t._v(" react 16.3+ 引入的两个生命周期")]),t._v(" "),s("p",[s("code",[t._v("getDerivedStateFromProps")]),t._v(" 的存在只有一个目的：让组件在 props 变化时更新 state")]),t._v(" "),s("p",[s("code",[t._v("getSnapshotBeforeUpdate()")]),t._v(" 在最近一次渲染输出（提交到 DOM 节点）之前调用")]),t._v(" "),s("p",[t._v("并将逐渐废弃componentWillMount()、componentWillReceiveProps()、componentWillUpdate()")]),t._v(" "),s("h4",{attrs:{id:"hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[t._v("#")]),t._v(" hooks")])])}),[],!1,null,null,null);e.default=r.exports}}]);