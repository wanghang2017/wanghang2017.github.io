(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{525:function(e,t,r){"use strict";r.r(t);var a=r(6),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"网络篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络篇"}},[e._v("#")]),e._v(" 网络篇")]),e._v(" "),r("h4",{attrs:{id:"网络层次划分-参考百度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络层次划分-参考百度"}},[e._v("#")]),e._v(" 网络层次划分  参考百度")]),e._v(" "),r("p",[e._v("应用层")]),e._v(" "),r("p",[e._v("与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。http  smtp  ftp")]),e._v(" "),r("p",[e._v("表示层")]),e._v(" "),r("p",[e._v("这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86",target:"_blank",rel:"noopener noreferrer"}},[e._v("字符集"),r("OutboundLink")],1),e._v("转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。")]),e._v(" "),r("p",[e._v("会话层")]),e._v(" "),r("p",[e._v("它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370",target:"_blank",rel:"noopener noreferrer"}},[e._v("数据"),r("OutboundLink")],1),e._v("，则用数据代表表示层。示例：RPC，SQL等。")]),e._v(" "),r("p",[e._v("传输层")]),e._v(" "),r("p",[e._v("这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA",target:"_blank",rel:"noopener noreferrer"}},[e._v("主机"),r("OutboundLink")],1),e._v("上对不同应用的"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81",target:"_blank",rel:"noopener noreferrer"}},[e._v("数据流"),r("OutboundLink")],1),e._v("的输入进行复用，还包括对收到的顺序不对的"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85",target:"_blank",rel:"noopener noreferrer"}},[e._v("数据包"),r("OutboundLink")],1),e._v("的重新排序功能。示例："),r("a",{attrs:{href:"https://baike.baidu.com/item/TCP/33012",target:"_blank",rel:"noopener noreferrer"}},[e._v("TCP"),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://baike.baidu.com/item/UDP/571511",target:"_blank",rel:"noopener noreferrer"}},[e._v("UDP"),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://baike.baidu.com/item/SPX/610336",target:"_blank",rel:"noopener noreferrer"}},[e._v("SPX"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("网络层")]),e._v(" "),r("p",[e._v("这层对端到端的包传输进行定义，它定义了能够标识所有结点的"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80",target:"_blank",rel:"noopener noreferrer"}},[e._v("逻辑地址"),r("OutboundLink")],1),e._v("，还定义了"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1",target:"_blank",rel:"noopener noreferrer"}},[e._v("路由"),r("OutboundLink")],1),e._v("实现的方式和学习的方式。为了适应"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83",target:"_blank",rel:"noopener noreferrer"}},[e._v("最大传输单元"),r("OutboundLink")],1),e._v("长度小于包长度的"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8",target:"_blank",rel:"noopener noreferrer"}},[e._v("传输介质"),r("OutboundLink")],1),e._v("，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。")]),e._v(" "),r("p",[e._v("数据链路层")]),e._v(" "),r("p",[e._v("它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例："),r("a",{attrs:{href:"https://baike.baidu.com/item/ATM/8314845",target:"_blank",rel:"noopener noreferrer"}},[e._v("ATM"),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://baike.baidu.com/item/FDDI/572177",target:"_blank",rel:"noopener noreferrer"}},[e._v("FDDI"),r("OutboundLink")],1),e._v("等。")]),e._v(" "),r("p",[e._v("物理层")]),e._v(" "),r("p",[e._v("OSI的物理层规范是有关"),r("a",{attrs:{href:"https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8",target:"_blank",rel:"noopener noreferrer"}},[e._v("传输介质"),r("OutboundLink")],1),e._v("的特性，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例："),r("a",{attrs:{href:"https://baike.baidu.com/item/Rj45/3401007",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rj45"),r("OutboundLink")],1),e._v("，"),r("a",{attrs:{href:"https://baike.baidu.com/item/802.3/960717",target:"_blank",rel:"noopener noreferrer"}},[e._v("802.3"),r("OutboundLink")],1),e._v("等。")]),e._v(" "),r("h4",{attrs:{id:"http-参考地址"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http-参考地址"}},[e._v("#")]),e._v(" HTTP  参考地址")]),e._v(" "),r("p",[e._v("1.HTTP/0.9  HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。")]),e._v(" "),r("p",[e._v("2.HTTP/1.0 增加了请求方式POST和HEAD；不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等；同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive。")]),e._v(" "),r("p",[e._v("3.HTTP/1.1 引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明"),r("code",[e._v("Connection: keep-alive")]),e._v("。解决了1.0版本的keepalive问题，1.1版本加入了持久连接，一个TCP连接可以允许多个HTTP请求；")]),e._v(" "),r("p",[e._v("4.HTTP/2.0 增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题（HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级）；HTTP请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率。另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。")]),e._v(" "),r("p",[e._v("服务器收到HTTP请求之后，会有多种方法响应这个请求，下面是HTTP响应的四种模型：")]),e._v(" "),r("p",[e._v("​    "),r("strong",[e._v("单进程I/O模型")])]),e._v(" "),r("p",[e._v("​\t服务端开启一个进程，一个进程仅能处理一个请求，并且对请求顺序处理；")]),e._v(" "),r("p",[e._v("​    "),r("strong",[e._v("多进程I/O模型")])]),e._v(" "),r("p",[e._v("​\t服务端并行开启多个进程，同样的一个进程只能处理一个请求，这样服务端就可以同时处理多个请求；")]),e._v(" "),r("p",[e._v("​    "),r("strong",[e._v("复用I/O模型")])]),e._v(" "),r("p",[e._v("​\t服务端开启一个进程，但是呢，同时开启多个线程，一个线程响应一个请求，同样可以达到同时处理多个请求，线程间并发执行；")]),e._v(" "),r("p",[e._v("​    "),r("strong",[e._v("复用多线程I/O模型")])]),e._v(" "),r("p",[e._v("​\t服务端并行开启多个进程，同时每个进程开启多个线程，这样服务端可以同时处理进程数M*每个进程的线程数N个请求。")]),e._v(" "),r("h4",{attrs:{id:"websocket-参考w3school"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#websocket-参考w3school"}},[e._v("#")]),e._v(" webSocket  参考w3school")]),e._v(" "),r("p",[e._v("很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。浪费很多的带宽资源。")]),e._v(" "),r("p",[e._v("WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯")]),e._v(" "),r("p",[e._v("WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。")]),e._v(" "),r("p",[e._v("握手采用http协议")]),e._v(" "),r("h4",{attrs:{id:"tcp-参考地址https-www-jianshu-com-p-ef892323e68f"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp-参考地址https-www-jianshu-com-p-ef892323e68f"}},[e._v("#")]),e._v(" TCP   参考地址https://www.jianshu.com/p/ef892323e68f")]),e._v(" "),r("p",[e._v("三次握手")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/2964446-aa923712d5218eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp",alt:"img"}})]),e._v(" "),r("p",[e._v("（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。")]),e._v(" "),r("p",[e._v("（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。")]),e._v(" "),r("p",[e._v("（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。")]),e._v(" "),r("p",[e._v("四次挥手")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/2964446-2b9562b3a8b72fb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp",alt:"img"}})]),e._v(" "),r("p",[e._v("（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。")]),e._v(" "),r("p",[e._v("（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。")]),e._v(" "),r("p",[e._v("（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。")]),e._v(" "),r("p",[e._v("（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。")])])}),[],!1,null,null,null);t.default=_.exports}}]);