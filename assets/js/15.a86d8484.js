(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{520:function(t,v,_){"use strict";_.r(v);var r=_(6),l=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"重写与重载的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重写与重载的区别"}},[t._v("#")]),t._v(" 重写与重载的区别")]),t._v(" "),_("p",[t._v("​\t1.重写:")]),t._v(" "),_("p",[t._v("​\t\t发生在继承过程中，子类对父类方法实现细节进行重写")]),t._v(" "),_("p",[t._v("​\t\t1）重写方法时，子类不能降低方法访问权限，可以扩大访问权限")]),t._v(" "),_("p",[t._v("​\t\t2）由private（本身就不能被继承）或者final修饰方法都不能被重写")]),t._v(" "),_("p",[t._v("​\t\t3）重写方法时，抛出异常可以是父类方法抛出异常的全集、子集、空集")]),t._v(" "),_("p",[t._v("​\t\t4）重写方法返回值 ，可以缩小返回类型的范围，但不能增加返回类型的范围")]),t._v(" "),_("p",[t._v("​\t2.重载：")]),t._v(" "),_("p",[t._v("​\t\tJAVa中允许同一个类文件中出现多个方法名相同")]),t._v(" "),_("p",[t._v("​\t\t但是参数列表不同的同名方法，这种现象成为重载")]),t._v(" "),_("p",[t._v("​\t\t要求两个方法名称必须相同，但是参数列表不能相同")]),t._v(" "),_("p",[t._v("​\t\t（个数不同/参数类型不同/参数类型出现顺虚不同）")]),t._v(" "),_("p",[t._v("​\t\t目的，让方法在接收不同参数时实现不同功能")]),t._v(" "),_("h2",{attrs:{id:"throw与throws得区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#throw与throws得区别"}},[t._v("#")]),t._v(" throw与throws得区别")]),t._v(" "),_("p",[t._v("1.throws")]),t._v(" "),_("p",[t._v("​\t1) 声明位置:  方法名后")]),t._v(" "),_("p",[t._v("​\t2) 作用: 通知开发人员当前方法在执行时，【有可能】抛出的异常")]),t._v(" "),_("p",[t._v("​\t3) 携带参数: throws后面携带【异常类型】，一个throws后面可以携带多个异常类型")]),t._v(" "),_("p",[t._v("​\t4）调用: 当一个方法被throws修饰时，调用方法时必须考虑异常捕捉问题")]),t._v(" "),_("p",[t._v("2.throw")]),t._v(" "),_("p",[t._v("​\t1）声明位置: 方法执行体")]),t._v(" "),_("p",[t._v("​\t2) 作用: throw是一个命令，执行时抛出一个指定异常对象")]),t._v(" "),_("p",[t._v("​\t3) 携带参数: throw后面携带【异常对象】，一个throw一次只能携带一个异常对象")]),t._v(" "),_("p",[t._v("​\t4）调用: 当一个方法的内部存在throw命令时，在调用时可以不考虑异常捕捉问题")]),t._v(" "),_("h2",{attrs:{id:"接口与抽象类的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口与抽象类的区别"}},[t._v("#")]),t._v(" 接口与抽象类的区别")]),t._v(" "),_("ol",[_("li",[t._v("接口：\n"),_("ol",[_("li",[t._v("是一种特殊 类文件")]),t._v(" "),_("li",[t._v("作用:\n"),_("ol",[_("li",[t._v("指定规则")]),t._v(" "),_("li",[t._v("降低耦合度")])])]),t._v(" "),_("li",[t._v("使用规则：\n"),_("ol",[_("li",[t._v("接口中属性，默认都是静态常量属性")]),t._v(" "),_("li",[t._v("接口中方法都是抽象，如果需要定义具体方法实现，此时方法需要使用default修饰")]),t._v(" "),_("li",[t._v("接口中方法访问权限不能是private")]),t._v(" "),_("li",[t._v("接口与接口之间可以实现多继承，但是接口之间不能相互实现")]),t._v(" "),_("li",[t._v("接口中不存在构造方法")])])])])]),t._v(" "),_("li",[t._v("抽象类：\n"),_("ol",[_("li",[t._v("抽象类由abstract修饰")]),t._v(" "),_("li",[t._v("抽象类作用降低接口实现类与接口之间实现难度")]),t._v(" "),_("li",[t._v("使用规则:\n"),_("ol",[_("li",[t._v("抽象类可以声明抽象方法，也可以生成具体方法")]),t._v(" "),_("li",[t._v("抽象类声明抽象方法必须由子类进行重写")]),t._v(" "),_("li",[t._v("抽象类实现接口时，不需要对接口方法进行重写")]),t._v(" "),_("li",[t._v("抽象类有构造方法，但是不能使用")])])])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);