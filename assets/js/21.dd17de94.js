(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{526:function(e,t,i){"use strict";i.r(t);var l=i(6),n=Object(l.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h3",{attrs:{id:"浏览器篇"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#浏览器篇"}},[e._v("#")]),e._v(" 浏览器篇")]),e._v(" "),i("h4",{attrs:{id:"_1-跨域"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-跨域"}},[e._v("#")]),e._v(" 1. 跨域")]),e._v(" "),i("p",[e._v("何为跨域 ？")]),e._v(" "),i("p",[e._v("协议+域名+端口号  有一个不同就是跨域")]),e._v(" "),i("p",[e._v("解决方案  jsonp  cors")]),e._v(" "),i("h4",{attrs:{id:"_2-浏览器加载、解析、渲染的过程-参考地址https-blog-csdn-net-xiaozhuxmen-article-details-52014901-utm-medium-distribute-pc-relevant-none-task-blog-blogcommendfrommachinelearnpai2-1-control-dist-request-id-1328592-9710-16147417308762129-depth-1-utm-source-distribute-pc-relevant-none-task-blog-blogcommendfrommachinelearnpai2-1-control"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器加载、解析、渲染的过程-参考地址https-blog-csdn-net-xiaozhuxmen-article-details-52014901-utm-medium-distribute-pc-relevant-none-task-blog-blogcommendfrommachinelearnpai2-1-control-dist-request-id-1328592-9710-16147417308762129-depth-1-utm-source-distribute-pc-relevant-none-task-blog-blogcommendfrommachinelearnpai2-1-control"}},[e._v("#")]),e._v(" 2. 浏览器加载、解析、渲染的过程      参考地址https://blog.csdn.net/XIAOZHUXMEN/article/details/52014901?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328592.9710.16147417308762129&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control")]),e._v(" "),i("p",[e._v("1.浏览器的渲染")]),e._v(" "),i("p",[e._v("解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树")]),e._v(" "),i("p",[i("img",{attrs:{src:"https://img-blog.csdn.net/20160724092250385",alt:"è¿éåå¾çæè¿°"}})]),e._v(" "),i("p",[e._v("浏览器会解析三个东西：\n（1） HTML/SVG/XHTML，解析这三种文件会产生一个 DOM Tree。\n（2） CSS，解析 CSS 会产生 CSS 规则树。\n（3） Javascript脚本，主要是通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree.")]),e._v(" "),i("p",[e._v("当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。\n解析：")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。")])]),e._v(" "),i("li",[i("p",[e._v("将CSS解析成 CSS Rule Tree 。")])]),e._v(" "),i("li",[i("p",[e._v("根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。\n"),i("img",{attrs:{src:"https://img-blog.csdn.net/20160724103859664",alt:"è¿éåå¾çæè¿°"}})])])]),e._v(" "),i("p",[e._v("4.有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。\n5.再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。")]),e._v(" "),i("ol",{attrs:{start:"2"}},[i("li",[i("p",[e._v("reflow 和 repaint")]),e._v(" "),i("p",[e._v("（1）Reflow（回流）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。\n（2）Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。\nReflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。")]),e._v(" "),i("p",[e._v("reflow原因：")]),e._v(" "),i("p",[e._v("（1）页面初始化的时候；\n（2）操作DOM时；\n（3）某些元素的尺寸变了；\n（4）如果 CSS 的属性发生变化了。")]),e._v(" "),i("p",[e._v("如何减少 reflow 和repaint")]),e._v(" "),i("p",[e._v("​\t（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。\n　（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。\n　（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。\n　（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。")])]),e._v(" "),i("li",[i("p",[e._v("总结渲染")]),e._v(" "),i("ol",[i("li",[e._v("用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；")]),e._v(" "),i("li",[e._v("浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；")]),e._v(" "),i("li",[e._v("浏览器又发出CSS文件的请求，服务器返回这个CSS文件；")]),e._v(" "),i("li",[e._v("浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；")]),e._v(" "),i("li",[e._v("浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；")]),e._v(" "),i("li",[e._v("服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；")]),e._v(" "),i("li",[e._v("浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它；")]),e._v(" "),i("li",[e._v("Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；")]),e._v(" "),i("li",[e._v("终于等到了＜/html＞的到来，浏览器泪流满面……")]),e._v(" "),i("li",[e._v("等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；")]),e._v(" "),i("li",[e._v("浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。")])])]),e._v(" "),i("li",[i("p",[e._v("注意问题")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。，因此，写css的时候需要注意：")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("dom深度尽量浅。")])]),e._v(" "),i("li",[i("p",[e._v("减少inline javascript、css的数量。")])]),e._v(" "),i("li",[i("p",[e._v("使用现代合法的css属性。")])]),e._v(" "),i("li",[i("p",[e._v("不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。")])]),e._v(" "),i("li",[i("p",[e._v("避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}")])]),e._v(" "),i("li",[i("p",[e._v("避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.")])])])]),e._v(" "),i("li",[i("p",[e._v("js")]),e._v(" "),i("p",[e._v("Javascript的加载和执行的特点：\n（1）载入后马上执行；\n（2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。原因：因为浏览器需要一个稳定的DOM树结构，而JS中很有可能有 代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现。")]),e._v(" "),i("p",[e._v("减少 JavaScript 对性能的影响的方法：")]),e._v(" "),i("ol",[i("li",[e._v("将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。")]),e._v(" "),i("li",[e._v("尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。")]),e._v(" "),i("li",[e._v("采用无阻塞下载 JavaScript 脚本的方法：\n（1）使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；\n（2）使用动态创建的script元素来下载并执行代码；")])])])])])])])}),[],!1,null,null,null);t.default=n.exports}}]);