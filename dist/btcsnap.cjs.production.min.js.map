{"version":3,"file":"btcsnap.cjs.production.min.js","sources":["../src/interface.ts","../src/bitcoin/getNetwork.ts","../src/errors/SnapError.ts","../src/errors/constant/PsbtValidaeErrors.ts","../src/errors/constant/RequestErrors.ts","../src/errors/constant/InvoiceErrors.ts","../src/rpc/validateRequest.ts","../src/bitcoin/xpubConverter.ts","../src/utils/unitHelper.ts","../src/utils/hexHelper.ts","../src/utils/manageState.ts","../src/bitcoin/hdKeyring.ts","../src/bitcoin/simpleKeyring.ts","../src/bitcoin/accountSinger.ts","../src/bitcoin/PsbtHelper.ts","../src/bitcoin/cryptoPath.ts","../src/bitcoin/PsbtValidator.ts","../src/bitcoin/transaction.ts","../src/bitcoin/index.ts","../src/utils/getHDNode.ts","../src/utils/transferLNData.ts","../src/index.ts","../src/rpc/getExtendedPublicKey.ts","../src/rpc/getSimpleAddress.ts","../src/rpc/getAllXpubs.ts","../src/rpc/signPSBT.ts","../src/rpc/getMasterFingerprint.ts","../src/rpc/manageNetwork.ts","../src/rpc/saveLNDataToSnap.ts","../src/rpc/getLNDataFromSnap.ts","../src/rpc/signLNInvoice.ts"],"sourcesContent":["export interface GetPublicExtendedKeyRequest {\n  method: 'btc_getPublicExtendedKey';\n  params: {\n    network: BitcoinNetwork;\n    scriptType: ScriptType;\n  };\n}\n\nexport interface GetAddress {\n  method: 'btc_getAddress';\n  params: {\n    network: BitcoinNetwork;\n    index: number;\n  };\n}\n\nexport interface GetAllXpubsRequest {\n  method: 'btc_getAllXpubs';\n  params: Record<string, never>;\n}\nexport interface SignPsbt {\n  method: 'btc_signPsbt';\n  params: {\n    psbt: string;\n    network: BitcoinNetwork;\n    scriptType: ScriptType;\n    signInputIndex: number;\n    signType: number;\n  };\n}\n\nexport interface GetMasterFingerprint {\n  method: 'btc_getMasterFingerprint';\n}\n\nexport interface ManageNetwork {\n  method: 'btc_network';\n  params: {\n    action: 'get' | 'set';\n    network?: BitcoinNetwork;\n  };\n}\n\nexport interface SaveLNDataToSnap {\n  method: 'btc_saveLNDataToSnap';\n  params: {\n    walletId: string;\n    credential: string;\n    password: string;\n  };\n}\n\nexport interface GetLNDataFromSnap {\n  method: 'btc_getLNDataFromSnap';\n  params: {\n    key: KeyOptions;\n    walletId?: string;\n    type?: 'get' | 'refresh';\n  };\n}\n\nexport interface SignLNInvoice {\n  method: 'btc_signLNInvoice';\n  params: {\n    invoice: string;\n  };\n}\n\nexport type MetamaskBTCRpcRequest =\n  | GetAllXpubsRequest\n  | GetAddress\n  | GetPublicExtendedKeyRequest\n  | SignPsbt\n  | GetMasterFingerprint\n  | ManageNetwork\n  | SaveLNDataToSnap\n  | GetLNDataFromSnap\n  | SignLNInvoice;\n\nexport type BTCMethodCallback = (\n  originString: string,\n  requestObject: MetamaskBTCRpcRequest,\n) => Promise<unknown>;\n\nexport interface Snap {\n  registerRpcMessageHandler: (fn: BTCMethodCallback) => unknown;\n  request<T>(options: {\n    method: string;\n    params?: unknown[] | Record<string, any>;\n  }): Promise<T>;\n}\n\nexport enum ScriptType {\n  P2PKH = 'P2PKH',\n  P2SH_P2WPKH = 'P2SH-P2WPKH',\n  P2WPKH = 'P2WPKH',\n  P2TR = 'P2TR',\n}\n\nexport enum BitcoinNetwork {\n  Main = 'main',\n  Test = 'test',\n}\n\nexport enum KeyOptions {\n  Password = 'password',\n  Credential = 'credential',\n  PubKey = 'pubkey',\n}\n\nconst LightningAccount = Buffer.from('Lightning').readInt32BE();\nexport const LNHdPath = `m/84'/0'/${LightningAccount}'/0/0`;\n\nexport interface PersistedData {\n  network?: BitcoinNetwork;\n  lightning?: {\n    [walletId: string]: {\n      credential: string;\n      password: string;\n    };\n  };\n}\n\nexport interface SLIP10Node {\n  /**\n   * The 0-indexed path depth of this node.\n   */\n  readonly depth: number;\n\n  /**\n   * The fingerprint of the master node, i.e., the node at depth 0. May be\n   * undefined if this node was created from an extended key.\n   */\n  readonly masterFingerprint?: number;\n\n  /**\n   * The fingerprint of the parent key, or 0 if this is a master node.\n   */\n  readonly parentFingerprint: number;\n\n  /**\n   * The index of the node, or 0 if this is a master node.\n   */\n  readonly index: number;\n\n  /**\n   * The private key of this node.\n   */\n  readonly privateKey: string;\n\n  /**\n   * The public key of this node.\n   */\n  readonly publicKey: string;\n\n  /**\n   * The chain code of this node.\n   */\n  readonly chainCode: string;\n\n  /**\n   * The name of the curve used by the node.\n   */\n  readonly curve: 'ed25519' | 'secp256k1';\n}\n","import { Network, networks } from 'bitcoinjs-lib';\nimport { BitcoinNetwork } from '../interface';\n\nexport function getNetwork(network: BitcoinNetwork): Network {\n  switch (network) {\n    case BitcoinNetwork.Main:\n      return networks.bitcoin;\n    case BitcoinNetwork.Test:\n      return networks.testnet;\n    default:\n      throw Error('Network net exist');\n  }\n}\n","export class SnapError extends Error {\n  code: number\n  constructor(code: number) {\n    super();\n    this.code = code;\n  }\n  \n  static of({code, message}: {code: number, message: string}){\n    const snapError = new SnapError(code)\n    snapError.message = message\n    return snapError\n  }\n}\n","export const PsbtValidateErrors = {\n  InputsDataInsufficient: {\n    code: 10001,\n    message: 'Not all inputs have prev Tx raw hex',\n  },\n  InputsNetworkNotMatch: {\n    code: 10002,\n    message: 'Not every input matches network'\n  },\n  OutputsNetworkNotMatch: {\n    code: 10003,\n    message: 'Not every output matches network'\n  },\n  InputNotSpendable: {\n    code: 10004,\n    message: 'Not all inputs belongs to current account'\n  },\n  ChangeAddressInvalid: {\n    code: 10005,\n    message: `Change address doesn't belongs to current account`\n  },\n  FeeTooHigh: {\n    code: 10006,\n    message: 'Too much fee'\n  },\n  AmountNotMatch: {\n    code: 10007,\n    message: 'Transaction input amount not match'\n  }\n}\n","export const RequestErrors = {\n  NoPermission: {\n    code: 20000,\n    message: 'Unauthorized to perform action.'\n  },\n  RejectKey: {\n    code: 20001,\n    message: 'User reject to access the key'\n  },\n  RejectSign: {\n    code: 20002,\n    message: 'User reject the sign request'\n  },\n  SignInvalidPath: {\n    code: 20003,\n    message:'invalid path'\n  },\n  SignFailed: {\n    code: 20004,\n    message: 'Sign transaction failed'\n  },\n  NetworkNotMatch: {\n    code: 20005,\n    message: 'Network not match'\n  },\n  ScriptTypeNotSupport: {\n    code: 20006,\n    message: 'ScriptType is not supported.'\n  },\n  MethodNotSupport: {\n    code: 20007,\n    message: 'Method not found.'\n  },\n  ActionNotSupport: {\n    code: 20008,\n    message: 'Action not supported'\n  },\n  UserReject: {\n    code: 20009,\n    message: 'User rejected the request.'\n  },\n  KeyNotSupported: {\n    code: 20010,\n    message: 'Key cannot be recognized'\n  },\n  DomainNotAllowed: {\n    code: 20011,\n    message: 'Domain not allowed'\n  }\n}\n","export const InvoiceErrors = {\n  AmountNotValid: {\n    code: 30001,\n    message: 'Amount is not valid',\n  },\n};\n","import {BitcoinNetwork, Snap} from '../interface';\nimport {getPersistedData} from '../utils/manageState';\nimport {RpcRequest} from '../index';\nimport { RequestErrors, SnapError } from '../errors';\n\nconst DOMAIN_WHITELIST = [/\\.justsnap\\.io$/];\n\nconst validateNetwork = async (snap: Snap, network: BitcoinNetwork) => {\n  // const snapNetwork = await getPersistedData(snap, 'network', '');\n  // if (snapNetwork && network !== snapNetwork) {\n  //   throw SnapError.of(RequestErrors.NetworkNotMatch);\n  // }\n};\n\nconst validateDomain = async (domain: string) => {\n  const isDomainValid = DOMAIN_WHITELIST.some((pattern) =>\n    pattern.test(domain),\n  );\n  if (!isDomainValid) {\n    throw SnapError.of(RequestErrors.DomainNotAllowed);\n  }\n};\n\nexport const validateRequest = async (\n  snap: Snap,\n  origin: string,\n  request: RpcRequest['request'],\n) => {\n  switch (request.method) {\n    case 'btc_getPublicExtendedKey':\n    case 'btc_signPsbt':\n      await validateNetwork(snap, request.params.network);\n      break;\n    case 'btc_getLNDataFromSnap':\n    case 'btc_saveLNDataToSnap':\n    case 'btc_signLNInvoice':\n      await validateDomain(origin);\n  }\n};\n","import { ScriptType, BitcoinNetwork } from \"../interface\";\nimport { Network, networks } from 'bitcoinjs-lib';\nimport { encode, decode } from \"bs58check\";\n\ntype XpubPrefix = \"xpub\" | \"tpub\" | \"ypub\" | \"upub\" | \"zpub\" | \"vpub\";\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0132.md#registered-hd-version-bytes\nconst xpubPrefixes: Record<XpubPrefix, string> = {\n  'xpub': '0488b21e',\n  'tpub': '043587cf',\n  'ypub': '049d7cb2',\n  'upub': '044a5262',\n  'zpub': '04b24746',\n  'vpub': '045f1cf6',\n}\n\nconst scriptTypeToXpubPrefix: Record<ScriptType, Record<BitcoinNetwork, XpubPrefix>> = {\n  [ScriptType.P2PKH]: {\n    main: 'xpub',\n    test: 'tpub'\n  },\n  [ScriptType.P2SH_P2WPKH]: {\n    main: 'ypub',\n    test: 'upub'\n  },\n  [ScriptType.P2WPKH]: {\n    main: 'zpub',\n    test: 'vpub'\n  },\n  [ScriptType.P2TR]: {\n    main: 'xpub',\n    test: 'tpub'\n  }\n}\n\nexport const convertXpub = (xpub: string, to: ScriptType, network: Network): string => {\n  const net = network === networks.bitcoin ? BitcoinNetwork.Main : BitcoinNetwork.Test;\n  const xpubPrefix = scriptTypeToXpubPrefix[to][net];\n\n  let data = decode(xpub);\n  data = data.slice(4);\n  data = Buffer.concat([Buffer.from(xpubPrefixes[xpubPrefix], \"hex\"), data]);\n  return encode(data);\n}","import BN from 'bn.js';\nimport { SnapError, InvoiceErrors } from '../errors';\n\nconst SATS_PER_BTC = new BN(1e8, 10);\n\ntype BitcoinDivisor  = 'm' | 'u' | 'n' | 'p';\n\nconst DIVISORS: Record<BitcoinDivisor, BN> = {\n  m: new BN(1e3, 10),\n  u: new BN(1e6, 10),\n  n: new BN(1e9, 10),\n  p: new BN(1e12, 10)\n};\n\nexport const hrpToSatoshi = (hrp: string):string => {\n  let divisor, value;\n  if (hrp.slice(-1).match(/^[munp]$/)) {\n    divisor = hrp.slice(-1);\n    value = hrp.slice(0, -1);\n  } else if (hrp.slice(-1).match(/^[^munp0-9]$/)) {\n    throw SnapError.of(InvoiceErrors.AmountNotValid);\n  } else {\n    value = hrp;\n  }\n\n  if (!value.match(/^\\d+$/)){\n    throw SnapError.of(InvoiceErrors.AmountNotValid);\n  }\n\n  const valueBN = new BN(value, 10);\n  const satoshisBN = divisor\n    ? valueBN.mul(SATS_PER_BTC).div(DIVISORS[divisor as BitcoinDivisor])\n    : valueBN.mul(SATS_PER_BTC);\n\n  return satoshisBN.toString();\n};\n","export const trimHexPrefix = (key: string) => key.startsWith('0x') ? key.substring(2) : key;\n","import {PersistedData, Snap} from '../interface';\n\nexport const getPersistedData = async <T>(\n  snap: Snap,\n  key: keyof PersistedData,\n  defaultValue: T,\n): Promise<T> => {\n  const persistedData = await snap.request<PersistedData>({\n    method: 'snap_manageState',\n    params: {\n      operation: 'get'\n    },\n  });\n  if (persistedData && persistedData[key]) {\n    return persistedData[key] as unknown as T;\n  }\n  return defaultValue;\n};\n\nexport const updatePersistedData = async (\n  snap: Snap,\n  key: keyof PersistedData,\n  value: any,\n) => {\n  const persistedData = await snap.request<PersistedData>({\n    method: 'snap_manageState',\n    params: {\n      operation: 'get'\n    },\n  });\n  const updatedData = {\n    ...persistedData,\n    [key]: value,\n  };\n\n  await snap.request({\n    method: 'snap_manageState',\n    params: {\n      operation: 'update',\n      newState: updatedData\n    },\n  });\n};\n","import { BIP32Factory, BIP32Interface } from 'bip32';\nimport { Network, networks } from 'bitcoinjs-lib';\nimport { ScriptType, SLIP10Node, Snap } from '../interface';\nimport ecc from '@bitcoinerlab/secp256k1';\nimport { trimHexPrefix } from '../utils';\n\nconst bip32 = BIP32Factory(ecc);\nexport const pathMap: Record<ScriptType, string[]> = {\n  [ScriptType.P2PKH]: ['m', \"44'\", \"0'\"],\n  [ScriptType.P2SH_P2WPKH]: ['m', \"49'\", \"0'\"],\n  [ScriptType.P2WPKH]: ['m', \"84'\", \"0'\"],\n  [ScriptType.P2TR]: ['m', \"86'\", \"0'\"],\n};\n\nexport const CRYPTO_CURVE = 'secp256k1';\n\nexport const toXOnly = (pubKey: Buffer) =>\n  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\n\nexport async function getHDRootNode(\n  snap: Snap,\n  network: Network,\n  scriptType: ScriptType = ScriptType.P2PKH,\n): Promise<{ node: BIP32Interface; mfp: string }> {\n  const path = [...pathMap[scriptType]];\n  if (network != networks.bitcoin) {\n    path[path.length - 1] = \"1'\";\n  }\n\n  const slip10Node = (await snap.request({\n    method: 'snap_getBip32Entropy',\n    params: {\n      path,\n      curve: CRYPTO_CURVE,\n    },\n  })) as SLIP10Node;\n\n  const privateKeyBuffer = Buffer.from(trimHexPrefix(slip10Node.privateKey), 'hex');\n  const chainCodeBuffer = Buffer.from(trimHexPrefix(slip10Node.chainCode), 'hex');\n\n  const node: BIP32Interface = bip32.fromPrivateKey(\n    privateKeyBuffer,\n    chainCodeBuffer,\n    network,\n  );\n  //@ts-ignore\n  // ignore checking since no function to set depth for node\n  node.__DEPTH = slip10Node.depth;\n  //@ts-ignore\n  // ignore checking since no function to set index for node\n  node.__INDEX = slip10Node.index;\n\n  const mfp = slip10Node.masterFingerprint.toString(16).padStart(8, '0');\n\n  return {\n    node: node.deriveHardened(0),\n    mfp,\n  };\n}\n","import { Network, networks, crypto, address, payments } from 'bitcoinjs-lib';\nimport bs58check from 'bs58check';\nimport { ScriptType } from 'interface';\n\nexport function privateKeyToWIF(privateKeyHex: string) {\n  const versionByte = Buffer.from([0x80]); // Mainnet version byte\n  const privateKeyBytes = Buffer.from(privateKeyHex, 'hex');\n  const extendedPrivateKey = Buffer.concat([versionByte, privateKeyBytes]);\n\n  return bs58check.encode(extendedPrivateKey);\n}\n\nexport function getAddress(\n  network: Network,\n  publicKey: string,\n  scriptType?: ScriptType,\n) {\n  const bufferPublicKey = Buffer.from(publicKey, 'hex');\n  const hash = crypto.hash160(bufferPublicKey);\n\n  const addresses: Record<string, string> = {};\n\n  if (network === networks.bitcoin) {\n    addresses['P2PKH'] = address.toBase58Check(hash, 0);\n\n    const result = payments.p2sh({\n      redeem: payments.p2wpkh({ pubkey: bufferPublicKey, network }),\n    });\n    addresses['P2SH-P2WPKH'] = result.address;\n\n    addresses['P2WPKH'] = address.toBech32(hash, 0, 'bc');\n\n    const p2trInstance = payments.p2tr({\n      internalPubkey: bufferPublicKey.slice(1),\n      network,\n    });\n    const tapRootAddress = p2trInstance.address;\n    addresses['P2TR'] = tapRootAddress;\n  } else if (network === networks.testnet) {\n    addresses['P2PKH'] = address.toBase58Check(hash, 111);\n\n    const result = payments.p2sh({\n      redeem: payments.p2wpkh({ pubkey: bufferPublicKey, network }),\n    });\n    addresses['P2SH-P2WPKH'] = result.address;\n\n    addresses['P2WPKH'] = address.toBech32(hash, 0, 'tb');\n\n    const p2trInstance = payments.p2tr({\n      internalPubkey: bufferPublicKey.slice(1),\n      network,\n    });\n    const tapRootAddress = p2trInstance.address;\n    addresses['P2TR'] = tapRootAddress;\n  }\n\n  console.log('addresses...', addresses);\n  if (scriptType) {\n    return addresses[scriptType];\n  }\n\n  return addresses;\n}\n","import ECPairFactory, { ECPairInterface } from 'ecpair';\nimport { BIP32Interface } from 'bip32';\nimport { Signer, HDSigner, crypto } from 'bitcoinjs-lib';\nimport ecc from '@bitcoinerlab/secp256k1';\n\nconst ECPair = ECPairFactory(ecc);\nexport class AccountSigner implements Signer, HDSigner {\n  publicKey: Buffer;\n  fingerprint: Buffer;\n\n  private readonly node: BIP32Interface;\n  private readonly keyPair: ECPairInterface;\n\n  constructor(accountNode: BIP32Interface, mfp?: Buffer) {\n    this.node = accountNode;\n    this.publicKey = this.node.publicKey;\n    this.fingerprint = mfp || this.node.fingerprint;\n\n    this.keyPair = ECPair.fromPrivateKey(this.node.privateKey, {\n      compressed: true,\n    });\n  }\n\n  getTapRootSinger(path = '0/0') {\n    const tapAccountSinger = this.derivePath(path);\n    const tweakedSinger = tapAccountSinger.node.tweak(\n      crypto.taggedHash('TapTweak', tapAccountSinger.node.publicKey.slice(1)),\n    );\n\n    return tweakedSinger;\n  }\n\n  derivePath(path: string): AccountSigner {\n    try {\n      let splitPath = path.split('/');\n      if (splitPath.length > 2) {\n        splitPath = splitPath.slice(-2);\n      }\n      const childNode = splitPath.reduce((prevHd, indexStr) => {\n        let index;\n        if (indexStr.slice(-1) === `'`) {\n          index = parseInt(indexStr.slice(0, -1), 10);\n          return prevHd.deriveHardened(index);\n        } else {\n          index = parseInt(indexStr, 10);\n          const node = prevHd.derive(index);\n          return node;\n        }\n      }, this.node);\n      return new AccountSigner(childNode, this.fingerprint);\n    } catch (e) {\n      throw new Error('invalid path');\n    }\n  }\n\n  sign(hash: Buffer): Buffer {\n    return this.keyPair.sign(hash);\n  }\n\n  signSchnorr(hash: Buffer): Buffer {\n    return this.keyPair.signSchnorr(hash);\n  }\n}\n\nexport const validator = (\n  pubkey: Buffer,\n  msghash: Buffer,\n  signature: Buffer,\n): boolean => {\n  return ECPair.fromPublicKey(pubkey).verify(msghash, signature);\n};\n\nexport const schnorrValidator = (\n  pubkey: Buffer,\n  msghash: Buffer,\n  signature: Buffer,\n): boolean => ecc.verifySchnorr(msghash, pubkey, signature);\n","import { address, Network, Psbt, Transaction } from 'bitcoinjs-lib';\nimport { getNetwork } from './getNetwork';\nimport { BitcoinNetwork } from '../interface';\n\nexport class PsbtHelper {\n  private tx: Psbt;\n  private network: Network;\n\n  constructor(psbt: Psbt, network: BitcoinNetwork) {\n    this.network = getNetwork(network);\n    this.tx = psbt;\n  }\n\n  get inputAmount() {\n    return this.tx.data.inputs.reduce((total, input, index) => {\n      const vout = this.tx.txInputs[index].index;\n      if (input.nonWitnessUtxo){\n        const prevTx = Transaction.fromHex(input.nonWitnessUtxo.toString('hex'));\n        return total + prevTx.outs[vout].value;\n      }else if(input.witnessUtxo){\n        return total + input.witnessUtxo.value;\n      }\n      return total;\n    }, 0);\n  }\n\n  get sendAmount() {\n    return this.tx.txOutputs\n      .filter(output => !this.changeAddresses.includes(output.address))\n      .reduce((amount, output) => amount + output.value, 0);\n  }\n\n  get fee() {\n    const outputAmount = this.tx.txOutputs.reduce((amount, output) => amount + output.value, 0);\n    return this.inputAmount - outputAmount;\n  }\n\n  get fromAddresses() {\n    return this.tx.data.inputs.map((input, index) => {\n      if (input.nonWitnessUtxo){\n        const prevOuts = Transaction.fromHex(input.nonWitnessUtxo.toString('hex')).outs\n        const vout = this.tx.txInputs[index].index;\n        return address.fromOutputScript(prevOuts[vout].script, this.network)\n      }else if(input.witnessUtxo){\n        return address.fromOutputScript(input.witnessUtxo.script, this.network)\n      }\n        return undefined;\n    })\n  }\n\n  get toAddresses() {\n    return this.tx.txOutputs.map(output => output.address).filter(address => !this.changeAddresses.includes(address));\n  }\n\n  get changeAddresses() {\n    return this.tx.data.outputs\n      .map((output, index) => output.bip32Derivation ? this.tx.txOutputs[index].address : undefined)\n      .filter(address => !!address)\n  }\n}\n","export interface HdPath {\n  purpose: string | null;\n  coinType: string | null;\n  account: string | null;\n  change: string | null;\n  index: string | null;\n}\n\nexport interface LightningPath {\n  purpose: {\n    value: string;\n    isHardened: boolean;\n  };\n  coinType: {\n    value: string;\n    isHardened: boolean;\n  };\n  account: {\n    value: string;\n    isHardened: boolean;\n  };\n  change: {\n    value: string;\n    isHardened: boolean;\n  };\n  index: {\n    value: string;\n    isHardened: boolean;\n  };\n}\n\nexport const fromHdPathToObj = (hdPath: string): HdPath => {\n  const regex = /(\\d)+/g;\n  const numbers = hdPath.match(regex);\n  return {\n    purpose: numbers && numbers[0],\n    coinType: numbers && numbers[1],\n    account: numbers && numbers[2],\n    change: numbers && numbers[3],\n    index: numbers && numbers[4],\n  };\n};\n\nexport const parseLightningPath = (hdPath: string): LightningPath => {\n  const regex = /(\\d'?)+/g;\n  const numbers = hdPath.match(regex);\n  const isHardened = (str:string) => {\n    return str.indexOf(\"'\") !== -1\n  }\n\n  return {\n    purpose: {\n      value: numbers && numbers[0],\n      isHardened: isHardened(numbers[0])\n    },\n    coinType: {\n      value: numbers && numbers[1],\n      isHardened: isHardened(numbers[1])\n    },\n    account: {\n      value: numbers && numbers[2],\n      isHardened: isHardened(numbers[2])\n    },\n    change: {\n      value: numbers && numbers[3],\n      isHardened: isHardened(numbers[3])\n    },\n    index: {\n      value: numbers && numbers[4],\n      isHardened: isHardened(numbers[4])\n    },\n  };\n};\n","import { Psbt } from 'bitcoinjs-lib';\nimport { AccountSigner } from './index';\nimport { BitcoinNetwork } from '../interface';\nimport { PsbtHelper } from '../bitcoin/PsbtHelper';\nimport { fromHdPathToObj } from './cryptoPath';\nimport { PsbtValidateErrors, SnapError } from '../errors';\n\nconst BITCOIN_MAINNET_COIN_TYPE = 0;\nconst BITCOIN_TESTNET_COIN_TYPE = 1;\nconst BITCOIN_MAIN_NET_ADDRESS_PATTERN = /^(1|3|bc1)/;\nconst BITCOIN_TEST_NET_ADDRESS_PATTERN = /^(m|n|2|tb1)/;\n\nexport class PsbtValidator {\n  static FEE_THRESHOLD = 10000000;\n  private readonly tx: Psbt;\n  private readonly snapNetwork: BitcoinNetwork;\n  private psbtHelper: PsbtHelper;\n  private error: SnapError | null = null;\n\n  constructor(psbt: Psbt, network: BitcoinNetwork) {\n    this.tx = psbt;\n    this.snapNetwork = network;\n    this.psbtHelper = new PsbtHelper(this.tx, network);\n  }\n\n  get coinType() {\n    return this.snapNetwork === BitcoinNetwork.Main\n      ? BITCOIN_MAINNET_COIN_TYPE\n      : BITCOIN_TESTNET_COIN_TYPE;\n  }\n\n  allInputsHaveRawTxHex() {\n    const result = this.tx.data.inputs.every(\n      (input) => !!input.nonWitnessUtxo || !!input.witnessUtxo,\n    );\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.InputsDataInsufficient);\n    }\n    return result;\n  }\n\n  everyInputMatchesNetwork() {\n    const result = this.tx.data.inputs.every((input) => {\n      if (input.bip32Derivation) {\n        return input.bip32Derivation.every((derivation) => {\n          const { coinType } = fromHdPathToObj(derivation.path);\n          return Number(coinType) === this.coinType;\n        });\n      }\n      return true;\n    });\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.InputsNetworkNotMatch);\n    }\n    return result;\n  }\n\n  everyOutputMatchesNetwork() {\n    const addressPattern =\n      this.snapNetwork === BitcoinNetwork.Main\n        ? BITCOIN_MAIN_NET_ADDRESS_PATTERN\n        : BITCOIN_TEST_NET_ADDRESS_PATTERN;\n    const result = this.tx.data.outputs.every((output, index) => {\n      if (output.bip32Derivation) {\n        return output.bip32Derivation.every((derivation) => {\n          const { coinType } = fromHdPathToObj(derivation.path);\n          return Number(coinType) === this.coinType;\n        });\n      } else {\n        const address = this.tx.txOutputs[index].address;\n        return addressPattern.test(address);\n      }\n    });\n\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.OutputsNetworkNotMatch);\n    }\n    return result;\n  }\n\n  allInputsBelongToCurrentAccount(accountSigner: AccountSigner) {\n    const result = this.tx.txInputs.every((_, index) =>{\n      if (this.tx.data.inputs[index].bip32Derivation) {\n        return this.tx.inputHasHDKey(index, accountSigner);\n      } else {\n        return true;\n        // TODO: P2TR地址校验\n        return this.tx.inputHasPubkey(index, accountSigner.publicKey);\n      }\n    });\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.InputNotSpendable);\n    }\n    return result;\n  }\n\n  someInputsBelongToCurrentAccount(accountSigner: AccountSigner) {\n    const result = this.tx.txInputs.some((_, index) => {\n      if (this.tx.data.inputs[index].bip32Derivation) {\n        return this.tx.inputHasHDKey(index, accountSigner);\n      } else {\n        return true;\n        // TODO: P2TR地址校验\n        return this.tx.inputHasPubkey(index, accountSigner.publicKey);\n      }\n    });\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.InputNotSpendable);\n    }\n    return result;\n  }\n\n  changeAddressBelongsToCurrentAccount(accountSigner: AccountSigner) {\n    const result = this.tx.data.outputs.every((output, index) => {\n      if (output.bip32Derivation) {\n        return this.tx.outputHasHDKey(index, accountSigner);\n      }\n      return true;\n    });\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.ChangeAddressInvalid);\n    }\n    return result;\n  }\n\n  feeUnderThreshold() {\n    const result = this.psbtHelper.fee < PsbtValidator.FEE_THRESHOLD;\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.FeeTooHigh);\n    }\n    return result;\n  }\n\n  witnessUtxoValueMatchesNoneWitnessOnes() {\n    const hasWitnessUtxo = this.tx.data.inputs.some(\n      (_, index) => this.tx.getInputType(index) === 'witnesspubkeyhash',\n    );\n    if (!hasWitnessUtxo) {\n      return true;\n    }\n\n    const witnessAmount = this.tx.data.inputs.reduce((total, input) => {\n      return total + input.witnessUtxo.value;\n    }, 0);\n    const result = this.psbtHelper.inputAmount === witnessAmount;\n\n    if (!result) {\n      this.error = SnapError.of(PsbtValidateErrors.AmountNotMatch);\n    }\n    return result;\n  }\n\n  validate(accountSigner: AccountSigner) {\n    this.error = null;\n\n    this.allInputsHaveRawTxHex() &&\n      this.everyInputMatchesNetwork() &&\n      this.everyOutputMatchesNetwork() &&\n      this.someInputsBelongToCurrentAccount(accountSigner) &&\n      // this.changeAddressBelongsToCurrentAccount(accountSigner) &&\n      this.feeUnderThreshold() &&\n      this.witnessUtxoValueMatchesNoneWitnessOnes();\n\n    if (this.error) {\n      throw this.error;\n    }\n    return true;\n  }\n}\n","import { Psbt, Transaction as bTransaction, script, Signer } from 'bitcoinjs-lib';\nimport { BitcoinNetwork, ScriptType } from '../interface';\nimport { PsbtValidator } from '../bitcoin/PsbtValidator';\nimport { PsbtHelper } from '../bitcoin/PsbtHelper';\nimport { getNetwork } from './getNetwork';\nimport { AccountSigner, validator, schnorrValidator } from './accountSinger';\n\nexport class Transaction {\n  private tx: Psbt;\n  private network: BitcoinNetwork;\n\n  constructor(base64Psbt: string, network: BitcoinNetwork) {\n    this.tx = Psbt.fromBase64(base64Psbt, { network: getNetwork(network) });\n    this.network = network;\n  }\n\n  validateTx(accountSigner: AccountSigner) {\n    const validator = new PsbtValidator(this.tx, this.network);\n    return validator.validate(accountSigner);\n  }\n\n  extractPsbtJson() {\n    const psbtHelper = new PsbtHelper(this.tx, this.network);\n    const changeAddress = psbtHelper.changeAddresses;\n    const unit = this.network === BitcoinNetwork.Main ? 'sats' : 'tsats';\n\n    const transaction = {\n      from: psbtHelper.fromAddresses.join(','),\n      to: psbtHelper.toAddresses.join(','),\n      value: `${psbtHelper.sendAmount} ${unit}`,\n      fee: `${psbtHelper.fee} ${unit}`,\n      network: `${this.network}net`,\n    };\n\n    if (changeAddress.length > 0) {\n      return { ...transaction, changeAddress: changeAddress.join(',') };\n    }\n    return transaction;\n  }\n\n  extractPsbtJsonString() {\n    return Object.entries(this.extractPsbtJson())\n      .map(([key, value]) => `${key}: ${value}\\n`)\n      .join('');\n  }\n\n  isDefinedSignType(signType: number) {\n    return (\n      signType === bTransaction.SIGHASH_DEFAULT ||\n      script.isDefinedHashType(signType)\n    );\n  }\n\n  signTx(\n    accountSigner: AccountSigner,\n    signInputIndex: number,\n    signType: number,\n    scriptType: ScriptType,\n  ) {\n    let signHashTypes;\n    if (signType && this.isDefinedSignType(signType)) {\n      signHashTypes = [signType];\n    }\n    \n    let signer: Signer;\n    if (scriptType === ScriptType.P2TR) {\n      signer = accountSigner.getTapRootSinger('0/0');\n    }\n\n    try {\n\n      if (signInputIndex && !this.isDefinedSignType(signInputIndex)) {\n        if (scriptType === ScriptType.P2TR) {\n          this.tx.signInput(signInputIndex, signer, signHashTypes);\n        } else {\n          this.tx.signInputHD(signInputIndex, accountSigner, signHashTypes);\n        }\n      } else {\n        if (scriptType === ScriptType.P2TR) {\n          this.tx.signAllInputs(signer, signHashTypes);\n        } else {\n          this.tx.signAllInputsHD(accountSigner, signHashTypes);\n        }\n      }\n\n      const txValidator = scriptType === ScriptType.P2TR?schnorrValidator: validator;\n      if (this.tx.validateSignaturesOfAllInputs(txValidator)) {\n        this.tx.finalizeAllInputs();\n        const txId = this.tx.extractTransaction().getId();\n        const txHex = this.tx.extractTransaction().toHex();\n        // TODO: sendTransaction to memoPool\n        return {\n          finally: true,\n          txId,\n          txHex,\n        };\n      } else {\n        return {\n          finally: false,\n          psbt: this.tx.toBase64(),\n        };\n      }\n    } catch (e) {\n      throw new Error(`Sign transaction failed...${JSON.stringify(e)}`);\n    }\n  }\n}\n","export * from './accountSinger';\nexport * from './simpleKeyring';\nexport * from './transaction';\nexport * from './getNetwork';\nexport * from './hdKeyring';\nexport * from './xpubConverter';\nexport * from './PsbtHelper';\nexport * from './PsbtValidator';\nimport ecc from '@bitcoinerlab/secp256k1';\nimport { initEccLib } from 'bitcoinjs-lib';\n\ninitEccLib(ecc);\n","import * as bip32 from 'bip32';\nimport {BIP32Interface} from 'bip32';\nimport {BitcoinNetwork, SLIP10Node, Snap} from '../interface';\nimport {getNetwork} from '../bitcoin/getNetwork';\nimport {parseLightningPath} from '../bitcoin/cryptoPath';\nimport { trimHexPrefix } from '../utils/hexHelper';\n\nconst CRYPTO_CURVE = 'secp256k1';\n\nexport const getHDNode = async (snap: Snap, hdPath: string) => {\n  const {purpose, coinType, account, change, index} =\n    parseLightningPath(hdPath);\n  const network =\n    coinType.value === '0'\n      ? getNetwork(BitcoinNetwork.Main)\n      : getNetwork(BitcoinNetwork.Test);\n  const path = ['m', purpose.value, coinType.value];\n\n  const slip10Node = (await snap.request({\n    method: 'snap_getBip32Entropy',\n    params: {\n      path: path,\n      curve: CRYPTO_CURVE,\n    },\n  })) as SLIP10Node;\n\n  const privateKeyBuffer = Buffer.from(trimHexPrefix(slip10Node.privateKey), 'hex');\n  const chainCodeBuffer = Buffer.from(trimHexPrefix(slip10Node.chainCode), 'hex');\n  // const node: BIP32Interface = bip32.fromPrivateKey(\n  //   privateKeyBuffer,\n  //   chainCodeBuffer,\n  //   network,\n  // );\n  const node = {} as BIP32Interface;\n\n  //@ts-ignore\n  // ignore checking since no function to set depth for node\n  node.__DEPTH = slip10Node.depth;\n  //@ts-ignore\n  // ignore checking since no function to set index for node\n  node.__INDEX = slip10Node.index;\n  // const pk = node.deriveHardened(1281976168).derive(0).derive(0).publicKey;\n  const deriveLNPath = () => {\n    let nodeLN = node;\n    [account, change, index].forEach((item) => {\n      if (item.isHardened) {\n        nodeLN = nodeLN.deriveHardened(parseInt(item.value));\n      }\n      if (!item.isHardened) {\n        nodeLN = nodeLN.derive(parseInt(item.value));\n      }\n    });\n    return nodeLN;\n  };\n\n  return deriveLNPath();\n};\n","import { hrpToSatoshi } from './unitHelper';\n\nexport const formatTime = (sec: number) => {\n  const hours = Math.floor(sec / 3600);\n  const minutes = Math.floor(sec % 3600 / 60);\n  if (hours <= 0 && minutes <= 0) {\n    return 'Expired';\n  }\n  return `${hours}H ${minutes}M`;\n};\n\nconst getBoltField = (invoice: Record<string, any>, key: string) => invoice.find((item:any) => item.name === key);\n\nconst formatInvoice = (invoice:string) => {\n  const decodedInvoice = require('light-bolt11-decoder').decode(invoice).sections;\n  const expireDatetime = getBoltField(decodedInvoice, 'timestamp').value + getBoltField(decodedInvoice, 'expiry').value;\n  return {\n    isMainnet: getBoltField(decodedInvoice, 'coin_network').value.bech32 === 'bc',\n    amount: hrpToSatoshi(getBoltField(decodedInvoice, 'amount').letters),\n    expireTime: expireDatetime - Math.floor(new Date().getTime() / 1000),\n    description: getBoltField(decodedInvoice, 'description').value\n  };\n};\n\nexport const transferInvoiceContent = (invoice: string) => {\n  const formattedInvoice = formatInvoice(invoice);\n  return {\n    network: `Lightning on Bitcoin ${formattedInvoice.isMainnet ? 'mainnet' : 'testnet'}`,\n    type: 'send',\n    amount: formattedInvoice.amount + ' sats',\n    expired_in: formatTime(formattedInvoice.expireTime),\n    description: formattedInvoice.description,\n  };\n};\n","import {getNetwork} from './bitcoin/getNetwork';\nimport {Snap, MetamaskBTCRpcRequest} from './interface';\nimport {\n  getExtendedPublicKey,\n  getSimpleAddress,\n  getAllXpubs,\n  signPsbt,\n  getMasterFingerprint,\n  manageNetwork,\n  validateRequest,\n  saveLNDataToSnap,\n  getLNDataFromSnap,\n  signLNInvoice,\n} from './rpc';\nimport {SnapError, RequestErrors} from './errors';\n\n// @ts-ignore\nglobalThis.Buffer = require('buffer/').Buffer;\n\ndeclare let snap: Snap;\n\nexport type RpcRequest = {\n  origin: string;\n  request: MetamaskBTCRpcRequest;\n};\n\nexport const onRpcRequest:any = async ({origin, request}: RpcRequest) => {\n  await validateRequest(snap, origin, request);\n\n  switch (request.method) {\n    case 'btc_getPublicExtendedKey':\n      return getExtendedPublicKey(\n        origin,\n        snap,\n        request.params.scriptType,\n        getNetwork(request.params.network),\n      );\n    case 'btc_getAddress':\n      return getSimpleAddress(\n        origin,\n        snap,\n        getNetwork(request.params.network),\n      );\n    case 'btc_getAllXpubs':\n      return getAllXpubs(origin, snap);\n    case 'btc_signPsbt':\n      const psbt = request.params.psbt;\n      return signPsbt(\n        origin,\n        snap,\n        psbt,\n        request.params.network,\n        request.params.scriptType,\n        request.params.signInputIndex,\n        request.params.signType\n      );\n    case 'btc_getMasterFingerprint':\n      return getMasterFingerprint(snap);\n    case 'btc_network':\n      return manageNetwork(\n        origin,\n        snap,\n        request.params.action,\n        request.params.network,\n      );\n    case 'btc_saveLNDataToSnap':\n      return saveLNDataToSnap(\n        origin,\n        snap,\n        request.params.walletId,\n        request.params.credential,\n        request.params.password,\n      );\n    case 'btc_getLNDataFromSnap':\n      return getLNDataFromSnap(origin, snap, {\n        key: request.params.key,\n        ...(request.params.walletId && {walletId: request.params.walletId}),\n        ...(request.params.type && {type: request.params.type}),\n      });\n    case 'btc_signLNInvoice':\n      return signLNInvoice(origin, snap, request.params.invoice);\n    default:\n      throw SnapError.of(RequestErrors.MethodNotSupport);\n  }\n};\n","import { Network, networks } from 'bitcoinjs-lib';\nimport { ScriptType, Snap } from '../interface';\nimport { convertXpub } from '../bitcoin/xpubConverter';\nimport { RequestErrors, SnapError } from '../errors';\nimport { heading, panel, text } from '@metamask/snaps-ui';\nimport { getHDRootNode } from '../bitcoin/hdKeyring';\nimport { getAddress } from '../bitcoin/simpleKeyring';\n\nexport async function getExtendedPublicKey(\n  origin: string,\n  snap: Snap,\n  scriptType: ScriptType,\n  network: Network,\n): Promise<{ xpub: string; mfp: string; address: string }> {\n  const networkName = network == networks.bitcoin ? 'mainnet' : 'testnet';\n  switch (scriptType) {\n    case ScriptType.P2PKH:\n    case ScriptType.P2WPKH:\n    case ScriptType.P2SH_P2WPKH:\n    case ScriptType.P2TR:\n      const result = await snap.request({\n        method: 'snap_dialog',\n        params: {\n          type: 'confirmation',\n          content: panel([\n            heading('Access your extended public key'),\n            text(\n              `Do you want to allow ${origin} to access Bitcoin ${networkName} ${scriptType} extended public key?`,\n            ),\n          ]),\n        },\n      });\n\n      if (result) {\n        const { node: accountNode, mfp } = await getHDRootNode(\n          snap,\n          network,\n          scriptType,\n        );\n\n        const address = getAddress(\n          network,\n          accountNode.publicKey.toString('hex'),\n          scriptType,\n        ) as string;\n\n        const extendedPublicKey = accountNode.neutered();\n        let xpub = extendedPublicKey.toBase58();\n        if (scriptType !== ScriptType.P2TR) {\n          xpub = convertXpub(xpub, scriptType, network);\n        }\n\n        return { mfp, xpub, address };\n      } else {\n        throw SnapError.of(RequestErrors.RejectKey);\n      }\n\n    default:\n      throw SnapError.of(RequestErrors.ScriptTypeNotSupport);\n  }\n}\n","import {\n  Network,\n  networks,\n} from 'bitcoinjs-lib';\nimport { ScriptType, Snap } from '../interface';\nimport { RequestErrors, SnapError } from '../errors';\nimport { heading, panel, text } from '@metamask/snaps-ui';\nimport { getHDRootNode } from '../bitcoin/hdKeyring';\nimport { getAddress, privateKeyToWIF } from '../bitcoin/simpleKeyring';\n\nexport async function getSimpleAddress(\n  origin: string,\n  snap: Snap,\n  network: Network,\n): Promise<Record<string, string> | string> {\n  const networkName = network == networks.bitcoin ? 'mainnet' : 'testnet';\n\n  const result = await snap.request({\n    method: 'snap_dialog',\n    params: {\n      type: 'confirmation',\n      content: panel([\n        heading('Access your account addresses'),\n        text(\n          `Do you want to allow ${origin} to access Bitcoin ${networkName} addresses?`,\n        ),\n      ]),\n    },\n  });\n\n  if (result) {\n    const { node } = await getHDRootNode(snap, network, ScriptType.P2PKH);\n\n    const publicKey = node.publicKey.toString('hex');\n    console.log('node public key...', publicKey, node.privateKey.toString('hex'));\n    console.log('wif privateKey...', privateKeyToWIF(node.privateKey.toString('hex')));\n\n    return getAddress(network, publicKey);\n  } else {\n    throw SnapError.of(RequestErrors.RejectKey);\n  }\n}\n","import { panel, text, heading } from '@metamask/snaps-ui';\nimport { networks, address } from 'bitcoinjs-lib';\nimport { BitcoinNetwork, ScriptType, Snap } from '../interface';\nimport { convertXpub } from '../bitcoin/xpubConverter';\nimport { RequestErrors, SnapError } from '../errors';\nimport { getHDRootNode } from '../bitcoin/hdKeyring';\nimport { getAddress } from '../bitcoin/simpleKeyring';\ninterface Account {\n  xpub: string;\n  scriptType: ScriptType;\n  network: BitcoinNetwork;\n  privateKey: string;\n  wif: string;\n  address: string;\n}\n\nexport async function getAllXpubs(origin: string, snap: Snap): Promise<{ xpubs: string[], accounts: {}, mfp: string }> {\n  const result = await snap.request({\n    method: 'snap_dialog',\n    params: {\n      type: 'confirmation',\n      content: panel([\n        heading('Access your extended public key'),\n        text(`${origin} is trying to access your Bitcoin Legacy, SegWit, TapRoot and Native SegWit extended public keys.`),\n      ]),\n    },\n  });\n\n  try {\n    if (result) {\n      let xfp = '';\n      const xpubs: string[] = [];\n      const accounts: Array<Account> = [];\n      await Promise.all(Object.values(BitcoinNetwork).map(async (bitcoinNetwork: BitcoinNetwork) => {\n        const network = bitcoinNetwork === BitcoinNetwork.Main ? networks.bitcoin : networks.testnet;\n        await Promise.all(Object.values(ScriptType).map(async (scriptType: ScriptType) => {\n          const { node: accountNode, mfp } = await getHDRootNode(snap, network, scriptType);\n          xfp = xfp || mfp;\n          const extendedPublicKey = accountNode.neutered();\n          const deriveAccount = accountNode.derive(0).derive(0);\n\n\n          let xpub = extendedPublicKey.toBase58();\n          if (scriptType !== ScriptType.P2TR) {\n            xpub = convertXpub(xpub, scriptType, network);\n          }\n          xpubs.push(xpub);\n          accounts.push({\n            xpub,\n            scriptType,\n            network: bitcoinNetwork,\n            privateKey: deriveAccount.privateKey.toString('hex'),\n            wif: deriveAccount.toWIF(),\n            address: getAddress(network, deriveAccount.publicKey.toString('hex'), scriptType) as string\n          })\n        }));\n      }));\n      console.log('accounts', accounts);\n      return {\n        mfp: xfp,\n        xpubs,\n        accounts,\n      };\n    }\n    throw SnapError.of(RequestErrors.RejectKey);\n  } catch (e) {\n    console.log('error', e)\n    return {\n      mfp: '',\n      xpubs: [],\n      accounts: []\n    }\n  }\n}\n","import { BitcoinNetwork, ScriptType, Snap } from '../interface';\nimport { AccountSigner, Transaction } from '../bitcoin';\nimport { getNetwork } from '../bitcoin/getNetwork';\nimport { SnapError, RequestErrors } from \"../errors\";\nimport { heading, panel, text, divider } from \"@metamask/snaps-ui\";\nimport { getHDRootNode } from '../bitcoin/hdKeyring';\n\ninterface ISignResult{\n  finally: boolean;\n  txId?: string;\n  txHex?: string;\n  psbt?: string;\n}\nexport async function signPsbt(domain: string, snap: Snap, psbt: string, network: BitcoinNetwork, scriptType: ScriptType, signInputIndex: number, signType: number): Promise<ISignResult> {\n  const tx = new Transaction(psbt, network);\n\n\n  \n  const txDetails = tx.extractPsbtJson()\n\n  const result = await snap.request({\n    method: 'snap_dialog',\n    params: {\n      type: 'confirmation',\n      content: panel([\n        heading('Sign Bitcoin Transaction'),\n        text(`Please verify this ongoing Transaction from ${domain}`),\n        divider(),\n        panel(Object.entries(txDetails).map(([key, value]) => text(`**${key}**:\\n ${value}`))),\n      ]),\n    },\n  });\n  \n\n  if (result) {\n    try{\n      const {node, mfp} = await getHDRootNode(snap, getNetwork(network), scriptType)\n      const signer = new AccountSigner(node, Buffer.from(mfp, 'hex'));\n      tx.validateTx(signer)\n\n      return tx.signTx(signer, signInputIndex, signType, scriptType)\n    }catch(e){\n      console.log('sign failed...', e);\n    }\n  \n    return { finally: false, txId: '123', txHex: '123' }\n  } else {\n    throw SnapError.of(RequestErrors.RejectSign);\n  }\n}\n","import { networks } from 'bitcoinjs-lib';\nimport { Snap } from '../interface';\nimport { getHDRootNode } from '../bitcoin/hdKeyring';\n\nexport async function getMasterFingerprint(snap: Snap): Promise<string | void> {\n  const {mfp} = await getHDRootNode(snap, networks.bitcoin);\n\n  return mfp;\n}\n","import { BitcoinNetwork, Snap } from '../interface';\nimport { getPersistedData, updatePersistedData } from '../utils/manageState';\nimport { RequestErrors, SnapError } from \"../errors\";\nimport { heading, panel, text } from \"@metamask/snaps-ui\";\n\nexport async function manageNetwork(origin: string, snap: Snap, action: 'get' | 'set', target?: BitcoinNetwork): Promise<string | void> {\n  switch (action) {\n    case 'get':\n      return getPersistedData<BitcoinNetwork | \"\">(snap, \"network\", \"\");\n    case 'set':\n      const result = await snap.request({\n        method: 'snap_dialog',\n        params: {\n          type: 'confirmation',\n          content: panel([\n            heading('Switch your network'),\n            text(`Do you want to allow ${origin} to switch Bitcoin network to ${target}?`),\n          ]),\n        },\n      });\n      if (result) {\n        await updatePersistedData(snap, \"network\", target)\n        return target;\n      } else {\n        return \"\";\n      }\n    default:\n      throw SnapError.of(RequestErrors.ActionNotSupport);\n  }\n}\n","import {Snap, LNHdPath} from '../interface';\nimport {getHDNode} from '../utils/getHDNode';\nimport {getPersistedData, updatePersistedData} from '../utils/manageState';\nimport CryptoJs from 'crypto-js';\n\nexport async function saveLNDataToSnap(\n  domain: string,\n  snap: Snap,\n  walletId: string,\n  credential: string,\n  password: string,\n) {\n  const privateKey = (await getHDNode(snap, LNHdPath)).privateKey.toString(\n    'hex',\n  );\n  const salt = CryptoJs.lib.WordArray.random(16);\n  const key = CryptoJs.PBKDF2(privateKey, salt, {\n    keySize: 16,\n    iterations: 1000,\n  });\n\n  const iv = CryptoJs.lib.WordArray.random(16);\n  const encrypted = CryptoJs.AES.encrypt(credential, key, {iv: iv});\n  const encryptText = salt.toString() + iv.toString() + encrypted.toString();\n  const result = await getPersistedData(snap, 'lightning', {});\n  const newLightning = {\n    ...result,\n    [walletId]: {\n      credential: encryptText,\n      password: password,\n    },\n  };\n\n  await updatePersistedData(snap, 'lightning', newLightning);\n}\n","import {getHDNode} from '../utils/getHDNode';\nimport {Snap, PersistedData, KeyOptions, LNHdPath} from '../interface';\nimport {getPersistedData} from '../utils/manageState';\nimport CryptoJs from 'crypto-js';\nimport { RequestErrors, SnapError } from \"../errors\";\nimport { heading, panel, text } from \"@metamask/snaps-ui\";\n\ninterface GetLNDataFromSnap {\n  key: KeyOptions,\n  walletId?: string,\n  type?: 'get' | 'refresh',\n}\n\nexport async function getLNDataFromSnap(\n  domain: string,\n  snap: Snap,\n  {\n    key,\n    walletId,\n    type = 'get',\n  }: GetLNDataFromSnap\n): Promise<string> {\n  switch (key) {\n    case KeyOptions.PubKey:\n      return (await getHDNode(snap, LNHdPath)).publicKey.toString('hex');\n    case KeyOptions.Password:\n      const lightning = await getPersistedData<PersistedData['lightning']>(\n        snap,\n        'lightning',\n        {},\n      );\n      return lightning[walletId].password;\n    case KeyOptions.Credential:\n      const param = {\n        get: {\n          prompt: 'Access your Lighting wallet credentials',\n          description: `Do you want to allow ${domain} to access your Lighting wallet credentials?`,\n        },\n        refresh: {\n          prompt: 'Lightning Wallet Data has Expired.',\n          description: 'For security purposes, Lightning Wallet data expires after 7 days and needs to be re-authorized.',\n        }\n      }[type]\n      const result = await snap.request({\n        method: 'snap_dialog',\n        params: {\n          type: 'confirmation',\n          content: panel([\n            heading(param.prompt),\n            text(param.description),\n          ]),\n        },\n      });\n      if (result) {\n        const lightning = await getPersistedData<PersistedData['lightning']>(\n          snap,\n          'lightning',\n          {},\n        );\n        const encryptText = lightning[walletId].credential;\n        const salt = CryptoJs.enc.Hex.parse(encryptText.substring(0, 32));\n        const iv = CryptoJs.enc.Hex.parse(encryptText.substring(32, 64));\n        const encrypted = encryptText.substring(64);\n        const privateKey = (\n          await getHDNode(snap, LNHdPath)\n        ).privateKey.toString('hex');\n        const key = CryptoJs.PBKDF2(privateKey, salt, {\n          keySize: 512 / 32,\n          iterations: 1000,\n        });\n        const credential = CryptoJs.AES.decrypt(encrypted, key, {iv: iv});\n\n        return credential.toString(CryptoJs.enc.Utf8);\n      } else {\n        throw SnapError.of(RequestErrors.UserReject);\n      }\n    default:\n      throw SnapError.of(RequestErrors.KeyNotSupported);\n  }\n}\n","import {Snap, LNHdPath} from '../interface';\nimport {getHDNode} from '../utils/getHDNode';\nimport {transferInvoiceContent} from '../utils/transferLNData';\nimport bitcoinMessage from 'bitcoinjs-message';\nimport { RequestErrors, SnapError } from '../errors';\nimport { divider, heading, panel, text } from \"@metamask/snaps-ui\";\n\nexport async function signLNInvoice(\n  domain: string,\n  snap: Snap,\n  invoice: string,\n): Promise<string> {\n  const invoiceContent = transferInvoiceContent(invoice);\n  const result = await snap.request({\n    method: 'snap_dialog',\n    params: {\n      type: 'confirmation',\n      content: panel([\n        heading('Sign Lightning Transaction'),\n        text(`Please verify this ongoing transaction from ${domain}`),\n        divider(),\n        panel(Object.entries(invoiceContent).map(([key, value]) => text(`**${key}**:\\n ${value}`))),\n      ]),\n    },\n  });\n\n  if (result) {\n    const privateKey = (await getHDNode(snap, LNHdPath)).privateKey;\n    const signature = bitcoinMessage\n      .sign(invoice, privateKey, true)\n      .toString('hex');\n    return signature;\n  } else {\n    throw SnapError.of(RequestErrors.RejectSign);\n  }\n}\n"],"names":["ScriptType","BitcoinNetwork","KeyOptions","LNHdPath","Buffer","from","readInt32BE","getNetwork","network","Main","networks","bitcoin","Test","testnet","Error","SnapError","constructor","code","super","this","[object Object]","message","snapError","PsbtValidateErrors","RequestErrors","InvoiceErrors","DOMAIN_WHITELIST","xpubPrefixes","xpub","tpub","ypub","upub","zpub","vpub","scriptTypeToXpubPrefix","P2PKH","main","test","P2SH_P2WPKH","P2WPKH","P2TR","convertXpub","to","xpubPrefix","data","decode","slice","concat","encode","SATS_PER_BTC","BN","DIVISORS","m","u","n","p","hrpToSatoshi","hrp","divisor","value","match","of","valueBN","mul","div","toString","trimHexPrefix","key","startsWith","substring","getPersistedData","async","snap","defaultValue","persistedData","request","method","params","operation","updatePersistedData","updatedData","newState","bip32","BIP32Factory","ecc","pathMap","getHDRootNode","scriptType","path","length","slip10Node","curve","privateKeyBuffer","privateKey","chainCodeBuffer","chainCode","node","fromPrivateKey","__DEPTH","depth","__INDEX","index","mfp","masterFingerprint","padStart","deriveHardened","getAddress","publicKey","bufferPublicKey","hash","crypto","hash160","addresses","address","toBase58Check","result","payments","p2sh","redeem","p2wpkh","pubkey","toBech32","p2trInstance","p2tr","internalPubkey","console","log","ECPair","ECPairFactory","AccountSigner","accountNode","fingerprint","keyPair","compressed","getTapRootSinger","tapAccountSinger","derivePath","tweak","taggedHash","splitPath","split","childNode","reduce","prevHd","indexStr","parseInt","derive","e","sign","signSchnorr","validator","msghash","signature","fromPublicKey","verify","schnorrValidator","verifySchnorr","PsbtHelper","psbt","tx","inputAmount","inputs","total","input","vout","txInputs","nonWitnessUtxo","Transaction","fromHex","outs","witnessUtxo","sendAmount","txOutputs","filter","output","changeAddresses","includes","amount","fee","outputAmount","fromAddresses","map","prevOuts","fromOutputScript","script","toAddresses","outputs","bip32Derivation","undefined","fromHdPathToObj","hdPath","numbers","purpose","coinType","account","change","BITCOIN_MAIN_NET_ADDRESS_PATTERN","BITCOIN_TEST_NET_ADDRESS_PATTERN","PsbtValidator","snapNetwork","psbtHelper","allInputsHaveRawTxHex","every","error","everyInputMatchesNetwork","derivation","Number","everyOutputMatchesNetwork","addressPattern","allInputsBelongToCurrentAccount","accountSigner","_","inputHasHDKey","someInputsBelongToCurrentAccount","some","changeAddressBelongsToCurrentAccount","outputHasHDKey","feeUnderThreshold","FEE_THRESHOLD","witnessUtxoValueMatchesNoneWitnessOnes","getInputType","witnessAmount","validate","base64Psbt","Psbt","fromBase64","validateTx","extractPsbtJson","changeAddress","unit","transaction","join","extractPsbtJsonString","Object","entries","isDefinedSignType","signType","bTransaction","SIGHASH_DEFAULT","isDefinedHashType","signTx","signInputIndex","signHashTypes","signer","signInput","signInputHD","signAllInputs","signAllInputsHD","validateSignaturesOfAllInputs","finalizeAllInputs","finally","txId","extractTransaction","getId","txHex","toHex","toBase64","JSON","stringify","getHDNode","isHardened","str","indexOf","parseLightningPath","deriveLNPath","nodeLN","forEach","item","formatTime","sec","hours","Math","floor","minutes","getBoltField","invoice","find","name","globalThis","require","origin","validateNetwork","pattern","domain","validateDomain","validateRequest","networkName","type","content","panel","heading","text","neutered","toBase58","getExtendedPublicKey","privateKeyHex","versionByte","privateKeyBytes","extendedPrivateKey","bs58check","privateKeyToWIF","getSimpleAddress","xfp","xpubs","accounts","Promise","all","values","bitcoinNetwork","extendedPublicKey","deriveAccount","push","wif","toWIF","getAllXpubs","txDetails","divider","signPsbt","getMasterFingerprint","action","target","manageNetwork","walletId","credential","password","salt","CryptoJs","lib","WordArray","random","PBKDF2","keySize","iterations","iv","encrypted","AES","encrypt","encryptText","newLightning","saveLNDataToSnap","PubKey","Password","Credential","param","get","prompt","description","refresh","enc","Hex","parse","decrypt","Utf8","getLNDataFromSnap","invoiceContent","formattedInvoice","decodedInvoice","sections","expireDatetime","isMainnet","bech32","letters","expireTime","Date","getTime","formatInvoice","expired_in","transferInvoiceContent","bitcoinMessage","signLNInvoice"],"mappings":"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"}