"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t,n,s,r=require("bitcoinjs-lib"),a=require("bs58check"),i=e(a),o=require("@metamask/snaps-ui"),c=require("bip32"),u=e(require("@bitcoinerlab/secp256k1")),p=e(require("bn.js")),d=e(require("ecpair")),h=e(require("crypto-js")),l=e(require("bitcoinjs-message"));!function(e){e.P2PKH="P2PKH",e.P2SH_P2WPKH="P2SH-P2WPKH",e.P2WPKH="P2WPKH",e.P2TR="P2TR"}(t||(t={})),function(e){e.Main="main",e.Test="test"}(n||(n={})),function(e){e.Password="password",e.Credential="credential",e.PubKey="pubkey"}(s||(s={}));const m=`m/84'/0'/${Buffer.from("Lightning").readInt32BE()}'/0/0`;function g(e){switch(e){case n.Main:return r.networks.bitcoin;case n.Test:return r.networks.testnet;default:throw Error("Network net exist")}}class f extends Error{constructor(e){super(),this.code=e}static of({code:e,message:t}){const n=new f(e);return n.message=t,n}}const w={code:10001,message:"Not all inputs have prev Tx raw hex"},y={code:10002,message:"Not every input matches network"},x={code:10003,message:"Not every output matches network"},b={code:10004,message:"Not all inputs belongs to current account"},P={code:10005,message:"Change address doesn't belongs to current account"},v={code:10006,message:"Too much fee"},k={code:10007,message:"Transaction input amount not match"},T={code:20001,message:"User reject to access the key"},H={code:20002,message:"User reject the sign request"},S={code:20006,message:"ScriptType is not supported."},K={code:20007,message:"Method not found."},_={code:20008,message:"Action not supported"},I={code:20009,message:"User rejected the request."},B={code:20010,message:"Key cannot be recognized"},A={code:20011,message:"Domain not allowed"},D={code:30001,message:"Amount is not valid"},W=[/\.justsnap\.io$/],q={xpub:"0488b21e",tpub:"043587cf",ypub:"049d7cb2",upub:"044a5262",zpub:"04b24746",vpub:"045f1cf6"},E={[t.P2PKH]:{main:"xpub",test:"tpub"},[t.P2SH_P2WPKH]:{main:"ypub",test:"upub"},[t.P2WPKH]:{main:"zpub",test:"vpub"},[t.P2TR]:{main:"xpub",test:"tpub"}},N=(e,t,s)=>{const i=E[t][s===r.networks.bitcoin?n.Main:n.Test];let o=a.decode(e);return o=o.slice(4),o=Buffer.concat([Buffer.from(q[i],"hex"),o]),a.encode(o)},$=new p(1e8,10),M={m:new p(1e3,10),u:new p(1e6,10),n:new p(1e9,10),p:new p(1e12,10)},O=e=>{let t,n;if(e.slice(-1).match(/^[munp]$/))t=e.slice(-1),n=e.slice(0,-1);else{if(e.slice(-1).match(/^[^munp0-9]$/))throw f.of(D);n=e}if(!n.match(/^\d+$/))throw f.of(D);const s=new p(n,10);return(t?s.mul($).div(M[t]):s.mul($)).toString()},R=e=>e.startsWith("0x")?e.substring(2):e,U=async(e,t,n)=>{const s=await e.request({method:"snap_manageState",params:{operation:"get"}});return s&&s[t]?s[t]:n},j=async(e,t,n)=>{const s={...await e.request({method:"snap_manageState",params:{operation:"get"}}),[t]:n};await e.request({method:"snap_manageState",params:{operation:"update",newState:s}})},L=c.BIP32Factory(u),F={[t.P2PKH]:["m","44'","0'"],[t.P2SH_P2WPKH]:["m","49'","0'"],[t.P2WPKH]:["m","84'","0'"],[t.P2TR]:["m","86'","0'"]};async function C(e,n,s=t.P2PKH){const a=[...F[s]];n!=r.networks.bitcoin&&(a[a.length-1]="1'");const i=await e.request({method:"snap_getBip32Entropy",params:{path:a,curve:"secp256k1"}}),o=Buffer.from(R(i.privateKey),"hex"),c=Buffer.from(R(i.chainCode),"hex"),u=L.fromPrivateKey(o,c,n);u.__DEPTH=i.depth,u.__INDEX=i.index;const p=i.masterFingerprint.toString(16).padStart(8,"0");return{node:u.deriveHardened(0),mfp:p}}function z(e,t,n){const s=Buffer.from(t,"hex"),a=r.crypto.hash160(s),i={};if(e===r.networks.bitcoin){i.P2PKH=r.address.toBase58Check(a,0);const t=r.payments.p2sh({redeem:r.payments.p2wpkh({pubkey:s,network:e})});i["P2SH-P2WPKH"]=t.address,i.P2WPKH=r.address.toBech32(a,0,"bc");const n=r.payments.p2tr({internalPubkey:s.slice(1),network:e});i.P2TR=n.address}else if(e===r.networks.testnet){i.P2PKH=r.address.toBase58Check(a,111);const t=r.payments.p2sh({redeem:r.payments.p2wpkh({pubkey:s,network:e})});i["P2SH-P2WPKH"]=t.address,i.P2WPKH=r.address.toBech32(a,0,"tb");const n=r.payments.p2tr({internalPubkey:s.slice(1),network:e});i.P2TR=n.address}return console.log("addresses...",i),n?i[n]:i}const J=d(u);class X{constructor(e,t){this.node=e,this.publicKey=this.node.publicKey,this.fingerprint=t||this.node.fingerprint,this.keyPair=J.fromPrivateKey(this.node.privateKey,{compressed:!0})}getTapRootSinger(e="0/0"){const t=this.derivePath(e);return t.node.tweak(r.crypto.taggedHash("TapTweak",t.node.publicKey.slice(1)))}derivePath(e){try{let t=e.split("/");t.length>2&&(t=t.slice(-2));const n=t.reduce((e,t)=>{let n;return"'"===t.slice(-1)?(n=parseInt(t.slice(0,-1),10),e.deriveHardened(n)):(n=parseInt(t,10),e.derive(n))},this.node);return new X(n,this.fingerprint)}catch(e){throw new Error("invalid path")}}sign(e){return this.keyPair.sign(e)}signSchnorr(e){return this.keyPair.signSchnorr(e)}}const V=(e,t,n)=>J.fromPublicKey(e).verify(t,n),G=(e,t,n)=>u.verifySchnorr(t,e,n);class Q{constructor(e,t){this.network=g(t),this.tx=e}get inputAmount(){return this.tx.data.inputs.reduce((e,t,n)=>{const s=this.tx.txInputs[n].index;return t.nonWitnessUtxo?e+r.Transaction.fromHex(t.nonWitnessUtxo.toString("hex")).outs[s].value:t.witnessUtxo?e+t.witnessUtxo.value:e},0)}get sendAmount(){return this.tx.txOutputs.filter(e=>!this.changeAddresses.includes(e.address)).reduce((e,t)=>e+t.value,0)}get fee(){const e=this.tx.txOutputs.reduce((e,t)=>e+t.value,0);return this.inputAmount-e}get fromAddresses(){return this.tx.data.inputs.map((e,t)=>{if(e.nonWitnessUtxo){const n=r.Transaction.fromHex(e.nonWitnessUtxo.toString("hex")).outs;return r.address.fromOutputScript(n[this.tx.txInputs[t].index].script,this.network)}if(e.witnessUtxo)return r.address.fromOutputScript(e.witnessUtxo.script,this.network)})}get toAddresses(){return this.tx.txOutputs.map(e=>e.address).filter(e=>!this.changeAddresses.includes(e))}get changeAddresses(){return this.tx.data.outputs.map((e,t)=>e.bip32Derivation?this.tx.txOutputs[t].address:void 0).filter(e=>!!e)}}const Y=e=>{const t=e.match(/(\d)+/g);return{purpose:t&&t[0],coinType:t&&t[1],account:t&&t[2],change:t&&t[3],index:t&&t[4]}},Z=/^(1|3|bc1)/,ee=/^(m|n|2|tb1)/;class te{constructor(e,t){this.error=null,this.tx=e,this.snapNetwork=t,this.psbtHelper=new Q(this.tx,t)}get coinType(){return this.snapNetwork===n.Main?0:1}allInputsHaveRawTxHex(){const e=this.tx.data.inputs.every(e=>!!e.nonWitnessUtxo||!!e.witnessUtxo);return e||(this.error=f.of(w)),e}everyInputMatchesNetwork(){const e=this.tx.data.inputs.every(e=>!e.bip32Derivation||e.bip32Derivation.every(e=>{const{coinType:t}=Y(e.path);return Number(t)===this.coinType}));return e||(this.error=f.of(y)),e}everyOutputMatchesNetwork(){const e=this.snapNetwork===n.Main?Z:ee,t=this.tx.data.outputs.every((t,n)=>t.bip32Derivation?t.bip32Derivation.every(e=>{const{coinType:t}=Y(e.path);return Number(t)===this.coinType}):e.test(this.tx.txOutputs[n].address));return t||(this.error=f.of(x)),t}allInputsBelongToCurrentAccount(e){const t=this.tx.txInputs.every((t,n)=>!this.tx.data.inputs[n].bip32Derivation||this.tx.inputHasHDKey(n,e));return t||(this.error=f.of(b)),t}someInputsBelongToCurrentAccount(e){const t=this.tx.txInputs.some((t,n)=>!this.tx.data.inputs[n].bip32Derivation||this.tx.inputHasHDKey(n,e));return t||(this.error=f.of(b)),t}changeAddressBelongsToCurrentAccount(e){const t=this.tx.data.outputs.every((t,n)=>!t.bip32Derivation||this.tx.outputHasHDKey(n,e));return t||(this.error=f.of(P)),t}feeUnderThreshold(){const e=this.psbtHelper.fee<te.FEE_THRESHOLD;return e||(this.error=f.of(v)),e}witnessUtxoValueMatchesNoneWitnessOnes(){if(!this.tx.data.inputs.some((e,t)=>"witnesspubkeyhash"===this.tx.getInputType(t)))return!0;const e=this.tx.data.inputs.reduce((e,t)=>e+t.witnessUtxo.value,0),t=this.psbtHelper.inputAmount===e;return t||(this.error=f.of(k)),t}validate(e){if(this.error=null,this.allInputsHaveRawTxHex()&&this.everyInputMatchesNetwork()&&this.everyOutputMatchesNetwork()&&this.someInputsBelongToCurrentAccount(e)&&this.feeUnderThreshold()&&this.witnessUtxoValueMatchesNoneWitnessOnes(),this.error)throw this.error;return!0}}te.FEE_THRESHOLD=1e7;class ne{constructor(e,t){this.tx=r.Psbt.fromBase64(e,{network:g(t)}),this.network=t}validateTx(e){return new te(this.tx,this.network).validate(e)}extractPsbtJson(){const e=new Q(this.tx,this.network),t=e.changeAddresses,s=this.network===n.Main?"sats":"tsats",r={from:e.fromAddresses.join(","),to:e.toAddresses.join(","),value:`${e.sendAmount} ${s}`,fee:`${e.fee} ${s}`,network:this.network+"net"};return t.length>0?{...r,changeAddress:t.join(",")}:r}extractPsbtJsonString(){return Object.entries(this.extractPsbtJson()).map(([e,t])=>`${e}: ${t}\n`).join("")}isDefinedSignType(e){return e===r.Transaction.SIGHASH_DEFAULT||r.script.isDefinedHashType(e)}signTx(e,n,s,r){let a,i;s&&this.isDefinedSignType(s)&&(a=[s]),r===t.P2TR&&(i=e.getTapRootSinger("0/0"));try{return n&&!this.isDefinedSignType(n)?r===t.P2TR?this.tx.signInput(n,i,a):this.tx.signInputHD(n,e,a):r===t.P2TR?this.tx.signAllInputs(i,a):this.tx.signAllInputsHD(e,a),this.tx.validateSignaturesOfAllInputs(r===t.P2TR?G:V)?(this.tx.finalizeAllInputs(),{finally:!0,txId:this.tx.extractTransaction().getId(),txHex:this.tx.extractTransaction().toHex()}):{finally:!1,psbt:this.tx.toBase64()}}catch(e){throw new Error("Sign transaction failed..."+JSON.stringify(e))}}}r.initEccLib(u);const se=async(e,t)=>{const{purpose:s,coinType:r,account:a,change:i,index:o}=(e=>{const t=e.match(/(\d'?)+/g),n=e=>-1!==e.indexOf("'");return{purpose:{value:t&&t[0],isHardened:n(t[0])},coinType:{value:t&&t[1],isHardened:n(t[1])},account:{value:t&&t[2],isHardened:n(t[2])},change:{value:t&&t[3],isHardened:n(t[3])},index:{value:t&&t[4],isHardened:n(t[4])}}})(t),c=(g("0"===r.value?n.Main:n.Test),["m",s.value,r.value]),u=await e.request({method:"snap_getBip32Entropy",params:{path:c,curve:"secp256k1"}}),p=(Buffer.from(R(u.privateKey),"hex"),Buffer.from(R(u.chainCode),"hex"),{});return p.__DEPTH=u.depth,p.__INDEX=u.index,(()=>{let e=p;return[a,i,o].forEach(t=>{t.isHardened&&(e=e.deriveHardened(parseInt(t.value))),t.isHardened||(e=e.derive(parseInt(t.value)))}),e})()},re=e=>{const t=Math.floor(e/3600),n=Math.floor(e%3600/60);return t<=0&&n<=0?"Expired":`${t}H ${n}M`},ae=(e,t)=>e.find(e=>e.name===t);globalThis.Buffer=require("buffer/").Buffer,exports.onRpcRequest=async({origin:e,request:a})=>{switch(await(async(e,t,n)=>{switch(n.method){case"btc_getPublicExtendedKey":case"btc_signPsbt":await(async(e,t)=>{})();break;case"btc_getLNDataFromSnap":case"btc_saveLNDataToSnap":case"btc_signLNInvoice":await(async e=>{if(!W.some(t=>t.test(e)))throw f.of(A)})(t)}})(snap,e,a),a.method){case"btc_getPublicExtendedKey":return async function(e,n,s,a){const i=a==r.networks.bitcoin?"mainnet":"testnet";switch(s){case t.P2PKH:case t.P2WPKH:case t.P2SH_P2WPKH:case t.P2TR:if(await n.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading("Access your extended public key"),o.text(`Do you want to allow ${e} to access Bitcoin ${i} ${s} extended public key?`)])}})){const{node:e,mfp:r}=await C(n,a,s),i=z(a,e.publicKey.toString("hex"),s);let o=e.neutered().toBase58();return s!==t.P2TR&&(o=N(o,s,a)),{mfp:r,xpub:o,address:i}}throw f.of(T);default:throw f.of(S)}}(e,snap,a.params.scriptType,g(a.params.network));case"btc_getAddress":return async function(e,n,s){const a=s==r.networks.bitcoin?"mainnet":"testnet";if(await n.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading("Access your account addresses"),o.text(`Do you want to allow ${e} to access Bitcoin ${a} addresses?`)])}})){const{node:e}=await C(n,s,t.P2PKH),r=e.publicKey.toString("hex");return console.log("node public key...",r,e.privateKey.toString("hex")),console.log("wif privateKey...",function(e){const t=Buffer.from([128]),n=Buffer.from(e,"hex"),s=Buffer.concat([t,n]);return i.encode(s)}(e.privateKey.toString("hex"))),z(s,r)}throw f.of(T)}(e,snap,g(a.params.network));case"btc_getAllXpubs":return async function(e,s){const a=await s.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading("Access your extended public key"),o.text(e+" is trying to access your Bitcoin Legacy, SegWit, TapRoot and Native SegWit extended public keys.")])}});try{if(a){let e="";const a=[],i=[];return await Promise.all(Object.values(n).map(async o=>{const c=o===n.Main?r.networks.bitcoin:r.networks.testnet;await Promise.all(Object.values(t).map(async n=>{const{node:r,mfp:u}=await C(s,c,n);e=e||u;const p=r.neutered(),d=r.derive(0).derive(0);let h=p.toBase58();n!==t.P2TR&&(h=N(h,n,c)),a.push(h),i.push({xpub:h,scriptType:n,network:o,privateKey:d.privateKey.toString("hex"),wif:d.toWIF(),address:z(c,d.publicKey.toString("hex"),n)})}))})),console.log("accounts",i),{mfp:e,xpubs:a,accounts:i}}throw f.of(T)}catch(e){return console.log("error",e),{mfp:"",xpubs:[],accounts:[]}}}(e,snap);case"btc_signPsbt":return async function(e,t,n,s,r,a,i){const c=new ne(n,s),u=c.extractPsbtJson();if(await t.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading("Sign Bitcoin Transaction"),o.text("Please verify this ongoing Transaction from "+e),o.divider(),o.panel(Object.entries(u).map(([e,t])=>o.text(`**${e}**:\n ${t}`)))])}})){try{const{node:e,mfp:n}=await C(t,g(s),r),o=new X(e,Buffer.from(n,"hex"));return c.validateTx(o),c.signTx(o,a,i,r)}catch(e){console.log("sign failed...",e)}return{finally:!1,txId:"123",txHex:"123"}}throw f.of(H)}(e,snap,a.params.psbt,a.params.network,a.params.scriptType,a.params.signInputIndex,a.params.signType);case"btc_getMasterFingerprint":return async function(e){const{mfp:t}=await C(e,r.networks.bitcoin);return t}(snap);case"btc_network":return async function(e,t,n,s){switch(n){case"get":return U(t,"network","");case"set":return await t.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading("Switch your network"),o.text(`Do you want to allow ${e} to switch Bitcoin network to ${s}?`)])}})?(await j(t,"network",s),s):"";default:throw f.of(_)}}(e,snap,a.params.action,a.params.network);case"btc_saveLNDataToSnap":return async function(e,t,n,s,r){const a=(await se(t,m)).privateKey.toString("hex"),i=h.lib.WordArray.random(16),o=h.PBKDF2(a,i,{keySize:16,iterations:1e3}),c=h.lib.WordArray.random(16),u=h.AES.encrypt(s,o,{iv:c}),p=i.toString()+c.toString()+u.toString(),d={...await U(t,"lightning",{}),[n]:{credential:p,password:r}};await j(t,"lightning",d)}(0,snap,a.params.walletId,a.params.credential,a.params.password);case"btc_getLNDataFromSnap":return async function(e,t,{key:n,walletId:r,type:a="get"}){switch(n){case s.PubKey:return(await se(t,m)).publicKey.toString("hex");case s.Password:return(await U(t,"lightning",{}))[r].password;case s.Credential:const n={get:{prompt:"Access your Lighting wallet credentials",description:`Do you want to allow ${e} to access your Lighting wallet credentials?`},refresh:{prompt:"Lightning Wallet Data has Expired.",description:"For security purposes, Lightning Wallet data expires after 7 days and needs to be re-authorized."}}[a];if(await t.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading(n.prompt),o.text(n.description)])}})){const e=(await U(t,"lightning",{}))[r].credential,n=h.enc.Hex.parse(e.substring(0,32)),s=h.enc.Hex.parse(e.substring(32,64)),a=e.substring(64),i=(await se(t,m)).privateKey.toString("hex"),o=h.PBKDF2(i,n,{keySize:16,iterations:1e3});return h.AES.decrypt(a,o,{iv:s}).toString(h.enc.Utf8)}throw f.of(I);default:throw f.of(B)}}(e,snap,{key:a.params.key,...a.params.walletId&&{walletId:a.params.walletId},...a.params.type&&{type:a.params.type}});case"btc_signLNInvoice":return async function(e,t,n){const s=(e=>{const t=(e=>{const t=require("light-bolt11-decoder").decode(e).sections,n=ae(t,"timestamp").value+ae(t,"expiry").value;return{isMainnet:"bc"===ae(t,"coin_network").value.bech32,amount:O(ae(t,"amount").letters),expireTime:n-Math.floor((new Date).getTime()/1e3),description:ae(t,"description").value}})(e);return{network:"Lightning on Bitcoin "+(t.isMainnet?"mainnet":"testnet"),type:"send",amount:t.amount+" sats",expired_in:re(t.expireTime),description:t.description}})(n);if(await t.request({method:"snap_dialog",params:{type:"confirmation",content:o.panel([o.heading("Sign Lightning Transaction"),o.text("Please verify this ongoing transaction from "+e),o.divider(),o.panel(Object.entries(s).map(([e,t])=>o.text(`**${e}**:\n ${t}`)))])}})){const e=(await se(t,m)).privateKey;return l.sign(n,e,!0).toString("hex")}throw f.of(H)}(e,snap,a.params.invoice);default:throw f.of(K)}};
//# sourceMappingURL=btcsnap.cjs.production.min.js.map
